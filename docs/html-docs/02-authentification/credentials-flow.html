<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Credentials Flow | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <!-- Sidebar injectée par layout.js -->
    <div id="sidebar-container"></div>

    <!-- Main Content -->
    <main class="main">
      <!-- Header injecté par layout.js -->
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Authentification</a>
          <span>/</span>
          <span>Credentials Flow</span>
        </div>

        <h1>Credentials Flow</h1>
        <p class="lead">
          L'authentification par credentials permet aux utilisateurs de s'inscrire et se connecter
          avec leur email et mot de passe. Le système inclut la vérification reCAPTCHA v3, une politique
          de mot de passe stricte, la sanitization XSS et la connexion automatique après vérification d'email.
        </p>

        <h2>Flux d'Inscription</h2>

        <div class="diagram">
          <div class="diagram-title">Processus d'inscription complet</div>
          <div class="mermaid">
sequenceDiagram
    participant U as Utilisateur
    participant F as Frontend /auth
    participant A as API /register
    participant DB as PostgreSQL
    participant E as Email Service

    U->>F: Remplit formulaire (firstName, lastName, email, password)
    F->>A: POST /api/auth/register + recaptchaToken
    A->>A: Vérifier reCAPTCHA v3 (score >= 0.5)
    A->>DB: Vérifier registration_enabled != '0'
    A->>A: Vérifier privacyPolicyAccepted
    A->>A: sanitizeEmail() + stripHtml()
    A->>A: validatePassword() (politique complète)
    A->>DB: Vérifier email unique
    A->>A: bcrypt.hash(password, 10)
    A->>DB: CREATE User (emailVerified: null)
    A->>DB: assignDefaultPlan() (plan gratuit)
    A->>DB: CREATE EmailVerificationToken
    A->>E: Envoyer email de vérification
    A->>F: 200 { ok: true, userId, message }
    F->>U: Redirection vers /auth/verify-email-required
          </div>
        </div>

        <h3>Endpoint d'Inscription</h3>

        <pre><code class="language-javascript">// POST /api/auth/register
// Body:
{
  firstName: "Jean",        // ou name: "Jean Dupont"
  lastName: "Dupont",
  email: "jean@exemple.fr",
  password: "MonPassword1!",
  recaptchaToken: "xxx",    // optionnel mais recommandé
  privacyPolicyAccepted: true  // obligatoire
}

// Réponse 200:
{
  ok: true,
  userId: "clx...",
  message: "Compte créé. Vérifiez votre email pour activer votre compte."
}</code></pre>

        <div class="callout callout-info">
          <div class="callout-title">Support des deux formats de nom</div>
          <p>L'API accepte soit <code>firstName</code> + <code>lastName</code> (nouveau format)
          soit <code>name</code> (format legacy). Le nom est nettoyé avec <code>stripHtml()</code>
          et doit faire au moins 2 caractères. Si firstName/lastName sont fournis, chacun doit
          faire au moins 2 caractères.</p>
        </div>

        <h2>Flux de Connexion</h2>

        <div class="diagram">
          <div class="diagram-title">Processus de connexion</div>
          <div class="mermaid">
sequenceDiagram
    participant U as Utilisateur
    participant F as Frontend
    participant NA as NextAuth (Credentials)
    participant DB as PostgreSQL

    U->>F: Email + Password
    F->>NA: signIn('credentials', { email, password, recaptchaToken })
    NA->>NA: Vérifier reCAPTCHA v3 (si fourni)
    NA->>DB: Vérifier maintenance_enabled
    alt Mode maintenance actif
        NA->>DB: Vérifier si user est ADMIN
        Note over NA: Non-ADMIN bloqué
    end
    NA->>DB: SELECT User WHERE email
    NA->>NA: bcrypt.compare(password, passwordHash)
    alt Password valide
        NA->>NA: Callback signIn (assignDefaultPlan, lastLoginAt, telemetry)
        NA->>NA: Callback JWT (enrichir token)
        NA->>F: Session JWT créée (7 jours)
        F->>U: Redirection dashboard /
    else Password invalide
        NA->>F: return null (erreur générique)
        F->>U: "Identifiants invalides"
    end
          </div>
        </div>

        <h3>Mode Auto Sign-In</h3>

        <p>Le CredentialsProvider supporte deux modes de connexion :</p>

        <div class="card-grid">
          <div class="card">
            <h4>Mode 1 : Auto Sign-In (Token)</h4>
            <p>Après vérification d'email, un token <code>autoSignInToken</code> est généré
            (32 bytes, expire en 5 minutes, usage unique). La page <code>/auth/complete-signin</code>
            l'utilise pour connecter automatiquement l'utilisateur.</p>
          </div>
          <div class="card">
            <h4>Mode 2 : Login Normal</h4>
            <p>Connexion classique email/password avec vérification reCAPTCHA et contrôle du mode maintenance.
            Le callback <code>signIn</code> gère l'attribution du plan, le tracking et la mise à jour
            <code>lastLoginAt</code>.</p>
          </div>
        </div>

        <pre><code class="language-javascript">// lib/auth/options.js - CredentialsProvider authorize()
async authorize(credentials) {
  // Mode 1: Connexion automatique avec token
  if (credentials?.autoSignInToken) {
    const verification = await verifyAutoSignInToken(credentials.autoSignInToken);
    if (!verification.valid) return null;

    const user = await prisma.user.findUnique({
      where: { id: verification.userId },
      select: { id: true, email: true, name: true, emailVerified: true },
    });

    if (!user || !user.emailVerified) return null;

    // Supprimer le token (usage unique)
    await deleteAutoSignInToken(credentials.autoSignInToken);
    return { id: user.id, email: user.email, name: user.name };
  }

  // Mode 2: Connexion normale email/password
  const email = credentials?.email?.toLowerCase().trim();
  const password = credentials?.password ?? "";
  if (!email || !password) return null;

  // Vérification reCAPTCHA
  if (credentials?.recaptchaToken) {
    const result = await verifyRecaptcha(credentials.recaptchaToken, {
      callerName: 'login', scoreThreshold: 0.5,
    });
    if (!result.success && !result.bypassed) return null;
  }

  // Mode maintenance
  const maintenanceSetting = await prisma.setting.findUnique({
    where: { settingName: 'maintenance_enabled' },
  });
  if (maintenanceSetting?.value === '1') {
    const userCheck = await prisma.user.findUnique({
      where: { email }, select: { role: true },
    });
    if (userCheck?.role !== 'ADMIN') return null;
  }

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user?.passwordHash) return null;
  const valid = await bcrypt.compare(password, user.passwordHash);
  if (!valid) return null;

  return { id: user.id, email: user.email, name: user.name };
}</code></pre>

        <h2>Politique de Mots de Passe</h2>

        <p>La validation est effectuée par <code>lib/security/passwordPolicy.js</code> via la fonction
        <code>validatePassword()</code>, utilisée à l'inscription, au changement de mot de passe et à la
        réinitialisation.</p>

        <table>
          <thead>
            <tr>
              <th>Règle</th>
              <th>Valeur</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Longueur minimale</td>
              <td>8 caractères</td>
            </tr>
            <tr>
              <td>Longueur maximale</td>
              <td>128 caractères (prévention DoS)</td>
            </tr>
            <tr>
              <td>Majuscule requise</td>
              <td>Au moins 1 lettre majuscule [A-Z]</td>
            </tr>
            <tr>
              <td>Minuscule requise</td>
              <td>Au moins 1 lettre minuscule [a-z]</td>
            </tr>
            <tr>
              <td>Chiffre requis</td>
              <td>Au moins 1 chiffre [0-9]</td>
            </tr>
            <tr>
              <td>Caractère spécial requis</td>
              <td>Au moins 1 (!@#$%^&*...)</td>
            </tr>
            <tr>
              <td>Blacklist mots courants</td>
              <td>30 mots de passe interdits (password, 123456, admin...)</td>
            </tr>
            <tr>
              <td>Pas de répétition</td>
              <td>Pas de caractère répété 3+ fois de suite (aaa)</td>
            </tr>
            <tr>
              <td>Pas de séquence</td>
              <td>Pas de séquences évidentes (abc, 123, 789)</td>
            </tr>
          </tbody>
        </table>

        <h3>Niveaux de Force</h3>

        <table>
          <thead>
            <tr>
              <th>Force</th>
              <th>Conditions</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>very_strong</code></td>
              <td>&ge; 16 chars + 4 types de caractères</td>
            </tr>
            <tr>
              <td><code>strong</code></td>
              <td>&ge; 14 chars + 3 types de caractères</td>
            </tr>
            <tr>
              <td><code>medium</code></td>
              <td>&ge; 8 chars + 3 types de caractères</td>
            </tr>
            <tr>
              <td><code>weak</code></td>
              <td>Toutes les autres combinaisons valides</td>
            </tr>
          </tbody>
        </table>

        <h2>Flux de Réinitialisation du Mot de Passe</h2>

        <div class="diagram">
          <div class="diagram-title">Processus complet de reset password</div>
          <div class="mermaid">
sequenceDiagram
    participant U as Utilisateur
    participant F as Frontend
    participant A1 as API /request-reset
    participant A2 as API /verify-reset-token
    participant A3 as API /reset-password
    participant DB as PostgreSQL
    participant E as Email Service

    Note over U,E: Étape 1 - Demande de réinitialisation (token expire en 1h)
    U->>F: Page /auth/forgot-password
    F->>A1: POST { email, recaptchaToken }
    A1->>A1: Vérifier reCAPTCHA v3
    A1->>DB: createPasswordResetToken(email)
    alt Utilisateur OAuth uniquement
        A1->>F: Erreur oauth_only
    else Utilisateur trouvé avec password
        A1->>E: Envoyer email reset
    end
    A1->>F: { success: true } (toujours, anti-énumération)

    Note over U,E: Étape 2 - Validation du token
    U->>F: Clic lien email -> /auth/reset-password?token=xxx
    F->>A2: GET /api/auth/verify-reset-token?token=xxx
    A2->>DB: verifyPasswordResetToken(token)
    A2->>F: { valid: true/false }

    Note over U,E: Étape 3 - Nouveau mot de passe
    U->>F: Saisit nouveau mot de passe
    F->>A3: POST { token, password }
    A3->>A3: validatePassword() (politique complète)
    A3->>DB: verifyPasswordResetToken(token)
    A3->>A3: bcrypt.hash(password, 10)
    A3->>DB: UPDATE User SET passwordHash
    A3->>DB: deletePasswordResetToken(userId)
    A3->>F: { success: true }
    F->>U: Redirection vers /auth (login)
          </div>
        </div>

        <div class="callout callout-info">
          <div class="callout-title">Expiration du token de reset</div>
          <p>Le token de réinitialisation expire après <strong>1 heure</strong>. Contrairement aux tokens de
          vérification email (table <code>EmailVerificationToken</code>, 24h) et auto-signin (table <code>AutoSignInToken</code>, 5 min),
          le token de reset est stocké directement sur le modèle <code>User</code> (<code>resetToken</code>, <code>resetTokenExpiry</code>).</p>
        </div>

        <div class="callout callout-warning">
          <div class="callout-title">Anti-énumération des emails</div>
          <p>L'endpoint <code>/api/auth/request-reset</code> retourne <strong>toujours</strong>
          <code>{ success: true }</code>, que l'email existe ou non en base.
          Cela empêche un attaquant de déterminer quels emails sont inscrits.
          Exception : si l'utilisateur est OAuth uniquement, une erreur <code>oauth_only</code>
          est retournée pour l'informer qu'il doit se connecter via son provider.</p>
        </div>

        <h2>Changement de Mot de Passe</h2>

        <pre><code class="language-javascript">// PUT /api/account/password
// Body:
{
  currentPassword: "AncienMdp1!",
  newPassword: "NouveauMdp2@"
}

// Processus:
// 1. Vérifier la session
// 2. validatePassword(newPassword) - politique complète
// 3. bcrypt.compare(currentPassword, user.passwordHash)
// 4. bcrypt.hash(newPassword, 10)
// 5. UPDATE User SET passwordHash

// Réponse: { ok: true }</code></pre>

        <div class="callout callout-info">
          <div class="callout-title">Utilisateurs OAuth sans mot de passe</div>
          <p>Si un utilisateur OAuth n'a pas de <code>passwordHash</code> (première fois), l'ancien
          mot de passe n'est pas vérifié. Cela permet aux utilisateurs OAuth de définir un mot de passe
          pour activer la connexion credentials en plus de leur provider OAuth.</p>
        </div>

        <h2>Suppression de Compte</h2>

        <div class="diagram">
          <div class="diagram-title">Processus de suppression de compte</div>
          <div class="mermaid">
sequenceDiagram
    participant U as Utilisateur
    participant F as Frontend /account
    participant A as API /account/delete
    participant S as Stripe
    participant DB as PostgreSQL

    U->>F: Confirmer suppression
    alt Utilisateur Credentials
        F->>A: DELETE { password: "xxx" }
        A->>A: bcrypt.compare(password)
    else Utilisateur OAuth
        F->>A: DELETE { email: "xxx@yyy.fr" }
        A->>A: Vérifier email == user.email
    end

    A->>S: Annuler abonnement Stripe
    A->>S: Supprimer customer Stripe
    A->>DB: DELETE User (cascade automatique)
    Note over DB: Cascade: Accounts, CvFiles, BackgroundTasks,<br/>LinkHistory, Feedbacks, ConsentLogs,<br/>TelemetryEvents, Subscriptions, CreditBalance...
    A->>A: Supprimer cookies session
    A->>F: { ok: true }
    F->>U: Déconnexion + redirection
          </div>
        </div>

        <h2>API Endpoints</h2>

        <table>
          <thead>
            <tr>
              <th>Endpoint</th>
              <th>Méthode</th>
              <th>Auth</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>/api/auth/register</code></td>
              <td>POST</td>
              <td>Non</td>
              <td>Inscription avec email/password</td>
            </tr>
            <tr>
              <td><code>/api/auth/[...nextauth]</code></td>
              <td>POST</td>
              <td>Non</td>
              <td>Connexion via NextAuth (credentials ou OAuth)</td>
            </tr>
            <tr>
              <td><code>/api/auth/request-reset</code></td>
              <td>POST</td>
              <td>Non</td>
              <td>Demander un email de réinitialisation</td>
            </tr>
            <tr>
              <td><code>/api/auth/verify-reset-token</code></td>
              <td>GET</td>
              <td>Non</td>
              <td>Vérifier la validité d'un token de reset (sans le consommer)</td>
            </tr>
            <tr>
              <td><code>/api/auth/reset-password</code></td>
              <td>POST</td>
              <td>Non</td>
              <td>Réinitialiser le mot de passe avec un token</td>
            </tr>
            <tr>
              <td><code>/api/account/password</code></td>
              <td>PUT</td>
              <td>Session</td>
              <td>Changer le mot de passe (vérifie l'ancien)</td>
            </tr>
            <tr>
              <td><code>/api/account/delete</code></td>
              <td>DELETE</td>
              <td>Session</td>
              <td>Supprimer le compte (cascade + Stripe)</td>
            </tr>
          </tbody>
        </table>

        <h2>Sanitization et Sécurité</h2>

        <div class="callout callout-warning">
          <div class="callout-title">Mesures de sécurité Credentials</div>
          <ul>
            <li><strong>Hachage</strong> : bcryptjs avec 10 salt rounds pour tous les mots de passe</li>
            <li><strong>reCAPTCHA v3</strong> : score &ge; 0.5 sur inscription et connexion (avec <code>BYPASS_RECAPTCHA</code> en dev)</li>
            <li><strong>XSS</strong> : <code>stripHtml()</code> sur le nom, <code>sanitizeEmail()</code> sur l'email</li>
            <li><strong>Politique de mot de passe</strong> : 8 règles de validation (voir ci-dessus)</li>
            <li><strong>Anti-énumération</strong> : message générique si email existe déjà ("Impossible de créer le compte")</li>
            <li><strong>Privacy</strong> : acceptation politique de confidentialité obligatoire (<code>privacyPolicyAcceptedAt</code>)</li>
            <li><strong>Mode maintenance</strong> : bloque les connexions credentials pour les non-admins</li>
            <li><strong>Toggle inscription</strong> : setting <code>registration_enabled</code> contrôle depuis l'admin</li>
          </ul>
        </div>

        <h2>Pages Frontend</h2>

        <table>
          <thead>
            <tr>
              <th>Route</th>
              <th>Fichier</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>/auth</code></td>
              <td><code>app/auth/page.jsx</code></td>
              <td>Page login/register combinée</td>
            </tr>
            <tr>
              <td><code>/auth/forgot-password</code></td>
              <td><code>app/auth/forgot-password/page.jsx</code></td>
              <td>Formulaire de demande de reset</td>
            </tr>
            <tr>
              <td><code>/auth/reset-password</code></td>
              <td><code>app/auth/reset-password/page.jsx</code></td>
              <td>Formulaire de nouveau mot de passe (avec ?token=xxx)</td>
            </tr>
            <tr>
              <td><code>/auth/complete-signin</code></td>
              <td><code>app/auth/complete-signin/page.jsx</code></td>
              <td>Auto-connexion après vérification email</td>
            </tr>
            <tr>
              <td><code>/auth/verify-email-required</code></td>
              <td><code>app/auth/verify-email-required/page.jsx</code></td>
              <td>Page d'attente de vérification email</td>
            </tr>
          </tbody>
        </table>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
