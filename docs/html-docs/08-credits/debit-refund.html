<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D&eacute;bit et Remboursement | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <div id="sidebar-container"></div>

    <main class="main">
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Cr&eacute;dits</a>
          <span>/</span>
          <span>D&eacute;bit / Remboursement</span>
        </div>

        <h1>D&eacute;bit et Remboursement</h1>
        <p class="lead">
          Toutes les op&eacute;rations sur le solde de cr&eacute;dits sont d&eacute;finies dans <code>lib/subscription/credits.js</code>. Chaque op&eacute;ration est <strong>atomique</strong> (transaction Prisma), &eacute;met un &eacute;v&eacute;nement SSE via <code>dbEmitter</code>, et cr&eacute;e une <code>CreditTransaction</code> pour tra&ccedil;abilit&eacute;.
        </p>

        <h2>Vue d'Ensemble des Fonctions</h2>

        <table>
          <thead>
            <tr>
              <th>Fonction</th>
              <th>Op&eacute;ration</th>
              <th>V&eacute;rifie la balance</th>
              <th>Balance n&eacute;gative possible</th>
              <th>&Eacute;v&eacute;nement SSE</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>debitCredit()</code></td>
              <td>D&eacute;bit usage</td>
              <td>Oui</td>
              <td>Non</td>
              <td><code>debit</code></td>
            </tr>
            <tr>
              <td><code>debitCredits()</code></td>
              <td>D&eacute;bit forc&eacute; (chargeback)</td>
              <td>Non</td>
              <td>Oui</td>
              <td><code>debit_forced</code></td>
            </tr>
            <tr>
              <td><code>refundCredit()</code></td>
              <td>Remboursement</td>
              <td>N/A</td>
              <td>N/A</td>
              <td><code>refund</code></td>
            </tr>
            <tr>
              <td><code>grantCredits()</code></td>
              <td>Attribution (achat, gift)</td>
              <td>N/A</td>
              <td>N/A</td>
              <td><code>grant</code></td>
            </tr>
            <tr>
              <td><code>getCreditBalance()</code></td>
              <td>Lecture solde</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>Aucun</td>
            </tr>
            <tr>
              <td><code>getCreditTransactions()</code></td>
              <td>Historique</td>
              <td>N/A</td>
              <td>N/A</td>
              <td>Aucun</td>
            </tr>
          </tbody>
        </table>

        <h2>getCreditBalance(userId)</h2>

        <p>R&eacute;cup&egrave;re le solde complet d'un utilisateur. <strong>Auto-cr&eacute;e</strong> la balance si elle n'existe pas (balance = 0).</p>

        <pre><code class="language-javascript">// lib/subscription/credits.js

export async function getCreditBalance(userId) {
  let creditBalance = await prisma.creditBalance.findUnique({
    where: { userId },
  });

  // Cr&eacute;er la balance si elle n'existe pas
  if (!creditBalance) {
    creditBalance = await prisma.creditBalance.create({
      data: {
        userId,
        balance: 0,
        totalPurchased: 0,
        totalUsed: 0,
        totalRefunded: 0,
        totalGifted: 0,
        balanceAfterLastPurchase: 0,
      },
    });
  }

  return creditBalance;
}

// Retourne: { balance, totalPurchased, totalUsed, totalRefunded,
//             totalGifted, balanceAfterLastPurchase }</code></pre>

        <h2>debitCredit(userId, amount, type, metadata)</h2>

        <p>D&eacute;bit <strong>atomique</strong> avec v&eacute;rification de la balance. Utilis&eacute; pour les usages normaux de features.</p>

        <pre><code class="language-javascript">// lib/subscription/credits.js

export async function debitCredit(userId, amount, type = 'usage', metadata = {}) {
  if (amount &lt;= 0) {
    return { success: false, error: 'Le montant doit &ecirc;tre sup&eacute;rieur &agrave; 0' };
  }

  try {
    // Transaction atomique pour garantir la coh&eacute;rence
    const result = await prisma.$transaction(async (tx) =&gt; {
      // V&eacute;rifier la balance actuelle
      const balance = await tx.creditBalance.findUnique({
        where: { userId },
      });

      if (!balance || balance.balance &lt; amount) {
        throw new Error('Cr&eacute;dits insuffisants');
      }

      // Cr&eacute;er la transaction de d&eacute;bit
      const transaction = await tx.creditTransaction.create({
        data: {
          userId,
          amount: -amount, // N&eacute;gatif pour d&eacute;bit
          type,
          featureName: metadata.featureName || null,
          taskId: metadata.taskId || null,
          cvFileId: metadata.cvFileId || null,
          metadata: metadata.extra ? JSON.stringify(metadata.extra) : null,
        },
      });

      // Mettre &agrave; jour la balance
      const updatedBalance = await tx.creditBalance.update({
        where: { userId },
        data: {
          balance: { decrement: amount },
          totalUsed: { increment: amount },
        },
      });

      return { transaction, balance: updatedBalance };
    });

    // &Eacute;mettre SSE pour mise &agrave; jour temps r&eacute;el
    dbEmitter.emitCreditsUpdate(userId, {
      action: 'debit', amount, newBalance: result.balance.balance, type,
    });

    return { success: true, transaction: result.transaction,
             balance: result.balance.balance };
  } catch (error) {
    return { success: false, error: error.message };
  }
}</code></pre>

        <div class="callout callout-info">
          <div class="callout-title">Transaction atomique</div>
          <p>La v&eacute;rification de la balance et le d&eacute;bit sont effectu&eacute;s dans une <strong>m&ecirc;me transaction Prisma</strong> (<code>prisma.$transaction()</code>), ce qui garantit qu'aucune race condition ne peut cr&eacute;er un solde n&eacute;gatif lors d'usages concurrents.</p>
        </div>

        <h2>debitCredits(userId, amount, type, metadata)</h2>

        <p>D&eacute;bit <strong>forc&eacute;</strong> sans v&eacute;rification de balance. Utilis&eacute; exclusivement pour les <strong>chargebacks</strong>. Peut rendre la balance n&eacute;gative.</p>

        <pre><code class="language-javascript">// lib/subscription/credits.js

export async function debitCredits(userId, amount, type = 'chargeback', metadata = {}) {
  if (amount &lt;= 0) {
    return { success: false, error: 'Le montant doit &ecirc;tre sup&eacute;rieur &agrave; 0' };
  }

  try {
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Cr&eacute;er la transaction de d&eacute;bit
      const transaction = await tx.creditTransaction.create({
        data: {
          userId,
          amount: -amount,
          type,
          relatedTransactionId: metadata.relatedTransactionId || null,
          metadata: JSON.stringify(metadata),
        },
      });

      // Mettre &agrave; jour ou cr&eacute;er la balance (SANS v&eacute;rifier si suffisant)
      const updatedBalance = await tx.creditBalance.upsert({
        where: { userId },
        create: {
          userId,
          balance: -amount, // Balance n&eacute;gative si pas de balance existante
          totalUsed: amount,
        },
        update: {
          balance: { decrement: amount }, // Peut devenir n&eacute;gatif
          totalUsed: { increment: amount },
        },
      });

      return { transaction, balance: updatedBalance };
    });

    dbEmitter.emitCreditsUpdate(userId, {
      action: 'debit_forced', amount, newBalance: result.balance.balance, type,
    });

    return { success: true, transaction: result.transaction,
             newBalance: result.balance.balance };
  } catch (error) {
    return { success: false, error: error.message };
  }
}</code></pre>

        <div class="callout callout-warning">
          <div class="callout-title">Balance n&eacute;gative = utilisateur bloqu&eacute;</div>
          <p>Quand la balance devient n&eacute;gative suite &agrave; un chargeback, <code>canUseFeature()</code> bloque <strong>toutes les fonctionnalit&eacute;s</strong> de l'utilisateur (c'est la toute premi&egrave;re v&eacute;rification de l'algorithme). L'utilisateur doit recharger des cr&eacute;dits pour r&eacute;gulariser.</p>
        </div>

        <h2>refundCredit(userId, originalTransactionId, reason)</h2>

        <p>Rembourse une transaction de d&eacute;bit sp&eacute;cifique. Utilis&eacute; automatiquement lors de l'&eacute;chec d'une <code>BackgroundTask</code>.</p>

        <pre><code class="language-javascript">// lib/subscription/credits.js

export async function refundCredit(userId, originalTransactionId,
                                   reason = 'Remboursement automatique') {
  try {
    // V&eacute;rifier d'abord si d&eacute;j&agrave; rembours&eacute;e (hors transaction pour &eacute;viter lock inutile)
    const existingTransaction = await prisma.creditTransaction.findUnique({
      where: { id: originalTransactionId },
      select: { refunded: true },
    });
    if (existingTransaction?.refunded) {
      return { success: true, alreadyRefunded: true };
    }

    // Transaction atomique
    const result = await prisma.$transaction(async (tx) =&gt; {
      const originalTransaction = await tx.creditTransaction.findUnique({
        where: { id: originalTransactionId },
      });
      if (!originalTransaction) throw new Error('Transaction introuvable');
      if (originalTransaction.userId !== userId)
        throw new Error('Transaction n\'appartient pas &agrave; cet utilisateur');
      if (originalTransaction.refunded) return { alreadyRefunded: true }; // Race condition
      if (originalTransaction.amount &gt;= 0)
        throw new Error('Seules les transactions de d&eacute;bit peuvent &ecirc;tre rembours&eacute;es');

      const refundAmount = Math.abs(originalTransaction.amount);

      // Cr&eacute;er la transaction de remboursement
      const refundTransaction = await tx.creditTransaction.create({
        data: {
          userId, amount: refundAmount, type: 'refund',
          featureName: originalTransaction.featureName,
          taskId: originalTransaction.taskId,
          relatedTransactionId: originalTransactionId,
          metadata: JSON.stringify({ reason }),
        },
      });

      // Marquer la transaction d'origine comme rembours&eacute;e
      await tx.creditTransaction.update({
        where: { id: originalTransactionId },
        data: { refunded: true },
      });

      // Incr&eacute;menter la balance
      const updatedBalance = await tx.creditBalance.update({
        where: { userId },
        data: {
          balance: { increment: refundAmount },
          totalRefunded: { increment: refundAmount },
        },
      });

      return { refundTransaction, balance: updatedBalance };
    });

    if (result.alreadyRefunded) return { success: true, alreadyRefunded: true };

    dbEmitter.emitCreditsUpdate(userId, {
      action: 'refund',
      amount: Math.abs(result.refundTransaction.amount),
      newBalance: result.balance.balance,
    });

    return { success: true, transaction: result.refundTransaction,
             balance: result.balance.balance };
  } catch (error) {
    return { success: false, error: error.message };
  }
}</code></pre>

        <div class="diagram">
          <div class="diagram-title">Flux de remboursement avec idempotence</div>
          <div class="mermaid">
flowchart TD
    Start["refundCredit(userId, txId)"] --> PreCheck{"Transaction d&eacute;j&agrave;<br/>rembours&eacute;e ?<br/>(hors transaction)"}
    PreCheck -->|"Oui"| AlreadyDone["Retourner success + alreadyRefunded"]
    PreCheck -->|"Non"| StartTx["D&eacute;marrer $transaction"]
    StartTx --> FindTx["R&eacute;cup&eacute;rer transaction originale"]
    FindTx --> Validate{"Validations:<br/>- Existe ?<br/>- M&ecirc;me userId ?<br/>- refunded = false ?<br/>- amount < 0 ?"}
    Validate -->|"&Eacute;chec"| Error["Retourner erreur"]
    Validate -->|"OK"| CreateRefund["Cr&eacute;er CreditTransaction<br/>(type: refund, amount: +N)"]
    CreateRefund --> MarkRefunded["Marquer originale:<br/>refunded = true"]
    MarkRefunded --> UpdateBal["Incr&eacute;menter balance<br/>+ totalRefunded"]
    UpdateBal --> EmitSSE["dbEmitter.emitCreditsUpdate()"]
    EmitSSE --> Done["Retourner success"]
          </div>
        </div>

        <h2>grantCredits(userId, amount, type, metadata)</h2>

        <p>Attribue des cr&eacute;dits (achat ou cadeau). Inclut une <strong>triple idempotence</strong> pour les achats Stripe.</p>

        <pre><code class="language-javascript">// lib/subscription/credits.js

export async function grantCredits(userId, amount, type = 'purchase', metadata = {}) {
  if (amount &lt;= 0) return { success: false, error: 'Montant invalide' };

  // V&eacute;rifier que l'utilisateur existe (FK check)
  const userExists = await prisma.user.findUnique({
    where: { id: userId }, select: { id: true },
  });
  if (!userExists) return { success: false, error: `Utilisateur ${userId} introuvable` };

  try {
    // Niveau 2: V&eacute;rification d'idempotence applicative
    if (metadata.stripePaymentIntentId) {
      const existingTransaction = await prisma.creditTransaction.findFirst({
        where: { stripePaymentIntentId: metadata.stripePaymentIntentId },
      });
      if (existingTransaction) {
        return { success: true, transaction: existingTransaction,
                 alreadyProcessed: true };
      }
    }

    // Transaction atomique
    const result = await prisma.$transaction(async (tx) =&gt; {
      const transaction = await tx.creditTransaction.create({
        data: {
          userId, amount, type,
          stripePaymentIntentId: metadata.stripePaymentIntentId || null,
          metadata: metadata.source ? JSON.stringify({
            source: metadata.source, pricePaid: metadata.pricePaid
          }) : null,
        },
      });

      // Calculer balanceAfterLastPurchase si achat
      let balanceAfterLastPurchaseValue = undefined;
      if (type === 'purchase') {
        const current = await tx.creditBalance.findUnique({
          where: { userId }, select: { balance: true },
        });
        balanceAfterLastPurchaseValue = (current?.balance || 0) + amount;
      }

      // Upsert CreditBalance
      const balance = await tx.creditBalance.upsert({
        where: { userId },
        create: {
          userId, balance: amount,
          totalPurchased: type === 'purchase' ? amount : 0,
          totalGifted: type === 'gift' ? amount : 0,
          balanceAfterLastPurchase: type === 'purchase' ? amount : 0,
        },
        update: {
          balance: { increment: amount },
          totalPurchased: type === 'purchase' ? { increment: amount } : undefined,
          totalGifted: type === 'gift' ? { increment: amount } : undefined,
          balanceAfterLastPurchase: balanceAfterLastPurchaseValue,
        },
      });

      return { transaction, balance };
    });

    dbEmitter.emitCreditsUpdate(userId, {
      action: 'grant', amount, newBalance: result.balance.balance, type,
    });

    return { success: true, transaction: result.transaction,
             balance: result.balance.balance };
  } catch (error) {
    // Niveau 3: Race condition - unique constraint P2002
    if (error.code === 'P2002' &amp;&amp; metadata.stripePaymentIntentId) {
      const existingTransaction = await prisma.creditTransaction.findFirst({
        where: { stripePaymentIntentId: metadata.stripePaymentIntentId },
      });
      return { success: true, transaction: existingTransaction,
               alreadyProcessed: true };
    }
    return { success: false, error: error.message };
  }
}</code></pre>

        <h3>Idempotence &agrave; 3 niveaux (achats Stripe)</h3>

        <table>
          <thead>
            <tr>
              <th>Niveau</th>
              <th>M&eacute;canisme</th>
              <th>Quand</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>1. Webhook</strong></td>
              <td><code>StripeWebhookLog.eventId</code> (unique)</td>
              <td>Avant dispatch vers le handler</td>
            </tr>
            <tr>
              <td><strong>2. Application</strong></td>
              <td><code>SELECT</code> sur <code>CreditTransaction.stripePaymentIntentId</code></td>
              <td>Avant la transaction Prisma dans grantCredits()</td>
            </tr>
            <tr>
              <td><strong>3. Database</strong></td>
              <td>Catch erreur <code>P2002</code> (unique constraint)</td>
              <td>Race condition entre 2 webhooks simultan&eacute;s</td>
            </tr>
          </tbody>
        </table>

        <h2>getCreditTransactions(userId, options)</h2>

        <pre><code class="language-javascript">// Signature
getCreditTransactions(userId, options = {})

// Options: { limit: 50, offset: 0, type: null }
// Retour: Array<CreditTransaction> tri&eacute;es par createdAt DESC

// Exemple d'appel
const transactions = await getCreditTransactions(userId, {
  limit: 20,
  offset: 0,
  type: 'usage',  // Filtrer par type (optionnel)
});</code></pre>

        <h2>&Eacute;v&eacute;nements SSE (Temps R&eacute;el)</h2>

        <p>Chaque op&eacute;ration de cr&eacute;dit &eacute;met un &eacute;v&eacute;nement via <code>dbEmitter.emitCreditsUpdate()</code>, permettant la mise &agrave; jour en temps r&eacute;el de l'UI sans rechargement de page.</p>

        <table>
          <thead>
            <tr>
              <th>Action SSE</th>
              <th>Fonction source</th>
              <th>Payload</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>debit</code></td>
              <td>debitCredit()</td>
              <td>amount, newBalance, type</td>
            </tr>
            <tr>
              <td><code>debit_forced</code></td>
              <td>debitCredits()</td>
              <td>amount, newBalance, type</td>
            </tr>
            <tr>
              <td><code>refund</code></td>
              <td>refundCredit()</td>
              <td>amount, newBalance</td>
            </tr>
            <tr>
              <td><code>grant</code></td>
              <td>grantCredits()</td>
              <td>amount, newBalance, type</td>
            </tr>
          </tbody>
        </table>

        <p><code>incrementFeatureCounter()</code> &eacute;met &eacute;galement des &eacute;v&eacute;nements <code>db:change</code> sur les entit&eacute;s <code>CreditBalance</code> et <code>FeatureUsageCounter</code> pour rafra&icirc;chir les compteurs dans l'UI.</p>

        <h2>Statistiques de la Balance</h2>

        <p>Le mod&egrave;le <code>CreditBalance</code> maintient des compteurs agr&eacute;g&eacute;s pour chaque utilisateur :</p>

        <table>
          <thead>
            <tr>
              <th>Champ</th>
              <th>Mis &agrave; jour par</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>balance</code></td>
              <td>Toutes les op&eacute;rations</td>
              <td>Solde courant (peut &ecirc;tre n&eacute;gatif apr&egrave;s chargeback)</td>
            </tr>
            <tr>
              <td><code>totalPurchased</code></td>
              <td>grantCredits(type='purchase')</td>
              <td>Total cr&eacute;dits achet&eacute;s depuis le d&eacute;but</td>
            </tr>
            <tr>
              <td><code>totalUsed</code></td>
              <td>debitCredit(), debitCredits()</td>
              <td>Total cr&eacute;dits consomm&eacute;s (incr&eacute;ment&eacute;, jamais d&eacute;cr&eacute;ment&eacute;)</td>
            </tr>
            <tr>
              <td><code>totalRefunded</code></td>
              <td>refundCredit()</td>
              <td>Total cr&eacute;dits rembours&eacute;s</td>
            </tr>
            <tr>
              <td><code>totalGifted</code></td>
              <td>grantCredits(type='gift')</td>
              <td>Total cr&eacute;dits offerts (bienvenue, admin)</td>
            </tr>
            <tr>
              <td><code>balanceAfterLastPurchase</code></td>
              <td>grantCredits(type='purchase')</td>
              <td>Balance imm&eacute;diatement apr&egrave;s le dernier achat</td>
            </tr>
          </tbody>
        </table>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
