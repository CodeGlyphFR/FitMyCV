<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mod&egrave;les &Eacute;conomiques | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <div id="sidebar-container"></div>

    <main class="main">
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Abonnements</a>
          <span>/</span>
          <span>Mod&egrave;les &eacute;conomiques</span>
        </div>

        <h1>Mod&egrave;les &Eacute;conomiques</h1>
        <p class="lead">
          FitMyCV.io impl&eacute;mente <strong>deux mod&egrave;les &eacute;conomiques</strong> distincts, configurables dynamiquement via l'interface d'administration. Le choix du mod&egrave;le affecte la fa&ccedil;on dont les utilisateurs acc&egrave;dent aux fonctionnalit&eacute;s.
        </p>

        <div class="callout callout-info">
          <div class="callout-title">Param&egrave;tre de configuration</div>
          <p>Le mode actif est contr&ocirc;l&eacute; par le setting <code>subscription_mode_enabled</code> dans la table <code>Setting</code>. Valeur par d&eacute;faut : <code>true</code>. La fonction <code>isSubscriptionModeEnabled()</code> de <code>lib/settings/settingsUtils.js</code> est utilis&eacute;e partout dans le code.</p>
        </div>

        <h2>Mod&egrave;le 1 : Abonnement + Extension Cr&eacute;dits</h2>

        <p><strong>Setting :</strong> <code>subscription_mode_enabled = true</code> (par d&eacute;faut)</p>

        <div class="diagram">
          <div class="diagram-title">Flux du mod&egrave;le Abonnement</div>
          <div class="mermaid">
flowchart TB
    subgraph Plans["PLANS D'ABONNEMENT"]
        Free["Gratuit<br/>tier 0 - 0&euro;"]
        Pro["Pro<br/>tier 1"]
        Premium["Premium<br/>tier 2"]
    end

    subgraph Limits["SYST&Egrave;ME DE LIMITES"]
        FL["SubscriptionPlanFeatureLimit"]
        Counter["FeatureUsageCounter<br/>(reset mensuel auto)"]
    end

    subgraph Usage["V&Eacute;RIFICATION"]
        Check{"canUseFeature()"}
        Premium2{"premiumRequired ?"}
    end

    subgraph Credits["EXTENSION CR&Eacute;DITS"]
        Buy["Achat pack cr&eacute;dits"]
        Balance["CreditBalance"]
    end

    subgraph Action["R&Eacute;SULTAT"]
        Execute["Ex&eacute;cuter + incr&eacute;menter compteur"]
        Block["Bloquer + Proposer upgrade/cr&eacute;dits"]
        PremExec["Ex&eacute;cuter sans cr&eacute;dit"]
    end

    Free & Pro & Premium --> FL
    FL --> Counter --> Check

    Check -->|"Limite non atteinte"| Execute
    Check -->|"Limite atteinte"| Balance
    Check -->|"Feature disabled"| Balance
    Balance -->|"Cr&eacute;dits OK"| Execute
    Balance -->|"Insuffisant"| Block
    Block --> Buy --> Balance

    Check -->|"premiumRequired"| Premium2
    Premium2 -->|"Plan Premium"| PremExec
    Premium2 -->|"Autre plan"| Block
          </div>
        </div>

        <h3>Caract&eacute;ristiques</h3>

        <div class="card-grid">
          <div class="card">
            <h4>Plans avec tiers</h4>
            <ul>
              <li><strong>Gratuit (tier 0)</strong> : Limites strictes, pas de Stripe</li>
              <li><strong>Pro (tier 1)</strong> : Limites &eacute;tendues, facturation Stripe</li>
              <li><strong>Premium (tier 2)</strong> : Illimit&eacute; + features exclusives</li>
            </ul>
          </div>
          <div class="card">
            <h4>Compteurs mensuels</h4>
            <ul>
              <li>Reset automatique au changement de p&eacute;riode</li>
              <li>Bas&eacute; sur date anniversaire abonnement</li>
              <li>Stockage : <code>FeatureUsageCounter</code> (1 par feature/user)</li>
              <li>Reset via <code>resetFeatureCounters()</code> au renouvellement</li>
            </ul>
          </div>
          <div class="card">
            <h4>Extension par cr&eacute;dits</h4>
            <ul>
              <li>Si limite atteinte &rarr; d&eacute;bit cr&eacute;dits automatique</li>
              <li>Si feature d&eacute;sactiv&eacute;e &rarr; cr&eacute;dits aussi</li>
              <li>Les cr&eacute;dits n'expirent jamais</li>
              <li>Co&ucirc;t 0 = feature r&eacute;serv&eacute;e Premium</li>
            </ul>
          </div>
        </div>

        <h3>Inscription (mode abonnement)</h3>

        <pre><code class="language-javascript">// lib/subscription/subscriptions.js - assignDefaultPlan()

// 1. Trouver le plan gratuit (priceMonthly === 0)
const freePlan = await prisma.subscriptionPlan.findFirst({
  where: { priceMonthly: 0, priceYearly: 0 }
});

// 2. Cr&eacute;er l'abonnement avec p&eacute;riode quasi-permanente (10 ans)
const subscription = await prisma.subscription.create({
  data: {
    userId,
    stripeCustomerId: `local_${userId}`, // Pas de Stripe pour le plan gratuit
    planId: freePlan.id,
    status: 'active',
    billingPeriod: 'monthly',
    currentPeriodStart: now,
    currentPeriodEnd: periodEnd, // +10 ans
  }
});

// 3. Initialiser la balance de cr&eacute;dits &agrave; 0
await prisma.creditBalance.create({
  data: { userId, balance: 0 }
});</code></pre>

        <h2>Mod&egrave;le 2 : Cr&eacute;dits Uniquement</h2>

        <p><strong>Setting :</strong> <code>subscription_mode_enabled = false</code></p>

        <div class="diagram">
          <div class="diagram-title">Flux du mod&egrave;le Cr&eacute;dits uniquement</div>
          <div class="mermaid">
flowchart TB
    subgraph Register["INSCRIPTION"]
        NewUser["Nouvel utilisateur"]
        Welcome["Cr&eacute;dits de bienvenue<br/>(setting: welcome_credits)"]
    end

    subgraph Usage["UTILISATION"]
        Balance["CreditBalance"]
        CostLookup["getCreditCostForFeature()"]
        Check{"Co&ucirc;t = 0 ?"}
        CredCheck{"Cr&eacute;dits >= co&ucirc;t ?"}
    end

    subgraph Purchase["ACHAT"]
        Packs["Packs de cr&eacute;dits<br/>(CreditPack)"]
    end

    subgraph Action["R&Eacute;SULTAT"]
        FreeExec["Ex&eacute;cuter (gratuit)"]
        PaidExec["Ex&eacute;cuter + D&eacute;biter"]
        Block["Bloquer + Proposer achat"]
    end

    NewUser --> Welcome --> Balance
    Balance --> CostLookup --> Check

    Check -->|"Oui"| FreeExec
    Check -->|"Non"| CredCheck

    CredCheck -->|"Oui"| PaidExec
    CredCheck -->|"Non"| Block

    Block --> Packs --> Balance
          </div>
        </div>

        <h3>Caract&eacute;ristiques</h3>

        <div class="card-grid">
          <div class="card">
            <h4>Pas d'abonnement Stripe</h4>
            <ul>
              <li>Aucune facturation r&eacute;currente</li>
              <li>Pas de Subscription cr&eacute;&eacute;e en base</li>
              <li>Mod&egrave;le "pay-as-you-go"</li>
              <li>Pas de compteurs mensuels</li>
            </ul>
          </div>
          <div class="card">
            <h4>Cr&eacute;dits de bienvenue</h4>
            <ul>
              <li>Attribu&eacute;s &agrave; l'inscription via <code>assignDefaultPlan()</code></li>
              <li>Montant : setting <code>welcome_credits</code> (d&eacute;faut : 0)</li>
              <li>Transaction type <code>gift</code> avec source <code>welcome_bonus</code></li>
            </ul>
          </div>
          <div class="card">
            <h4>Co&ucirc;t = 0 signifie GRATUIT</h4>
            <ul>
              <li>En mode cr&eacute;dits : co&ucirc;t 0 = feature gratuite</li>
              <li>En mode abonnement : co&ucirc;t 0 = Premium requis</li>
              <li><strong>S&eacute;mantique diff&eacute;rente selon le mode</strong></li>
            </ul>
          </div>
        </div>

        <h3>Inscription (mode cr&eacute;dits)</h3>

        <pre><code class="language-javascript">// lib/subscription/subscriptions.js - assignDefaultPlan()

// En mode cr&eacute;dits-only : pas de Subscription, juste des cr&eacute;dits
const welcomeCredits = await getNumericSettingValue('welcome_credits', 0);

await prisma.creditBalance.create({
  data: {
    userId,
    balance: welcomeCredits,
    totalGifted: welcomeCredits,
  }
});

// Transaction de tra&ccedil;abilit&eacute;
if (welcomeCredits > 0) {
  await prisma.creditTransaction.create({
    data: {
      userId,
      amount: welcomeCredits,
      type: 'gift',
      metadata: JSON.stringify({ source: 'welcome_bonus' }),
    }
  });
}</code></pre>

        <h2>Comparaison des Mod&egrave;les</h2>

        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Mode Abonnement</th>
              <th>Mode Cr&eacute;dits</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Facturation</strong></td>
              <td>R&eacute;currente (mensuelle/annuelle)</td>
              <td>Ponctuelle (&agrave; l'achat)</td>
            </tr>
            <tr>
              <td><strong>Inscription</strong></td>
              <td>Subscription + plan Gratuit</td>
              <td>CreditBalance + cr&eacute;dits bienvenue</td>
            </tr>
            <tr>
              <td><strong>V&eacute;rification acc&egrave;s</strong></td>
              <td>Plan &rarr; FeatureLimit &rarr; Compteur &rarr; Cr&eacute;dits</td>
              <td>Co&ucirc;t feature &rarr; Balance cr&eacute;dits</td>
            </tr>
            <tr>
              <td><strong>Co&ucirc;t = 0</strong></td>
              <td><code>premiumRequired = true</code></td>
              <td>Feature gratuite</td>
            </tr>
            <tr>
              <td><strong>Stripe Products</strong></td>
              <td>Subscriptions + Credit Packs</td>
              <td>Credit Packs uniquement</td>
            </tr>
            <tr>
              <td><strong>Webhooks utilis&eacute;s</strong></td>
              <td>Tous les 8 events</td>
              <td>checkout.session.completed, payment_intent.succeeded, charge.succeeded, charge.dispute.created</td>
            </tr>
            <tr>
              <td><strong>Compteurs mensuels</strong></td>
              <td>Oui (FeatureUsageCounter)</td>
              <td>Non</td>
            </tr>
            <tr>
              <td><strong>Upgrade path</strong></td>
              <td>Gratuit &rarr; Pro &rarr; Premium</td>
              <td>Achat de plus de cr&eacute;dits</td>
            </tr>
          </tbody>
        </table>

        <h2>Co&ucirc;ts par Feature</h2>

        <p>Les co&ucirc;ts sont stock&eacute;s dans la table <code>Setting</code> avec le pr&eacute;fixe <code>credits_</code>. Ils sont r&eacute;cup&eacute;r&eacute;s dynamiquement par <code>getCreditCostForFeature()</code> (pas de cache).</p>

        <table>
          <thead>
            <tr>
              <th>Feature</th>
              <th>Co&ucirc;t (cr&eacute;dits)</th>
              <th>Setting Key</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Cr&eacute;ation CV manuelle</td>
              <td><strong>1</strong></td>
              <td><code>credits_create_cv_manual</code></td>
            </tr>
            <tr>
              <td>&Eacute;dition CV</td>
              <td><strong>1</strong></td>
              <td><code>credits_edit_cv</code></td>
            </tr>
            <tr>
              <td>Export CV (PDF/DOCX)</td>
              <td><strong>1</strong></td>
              <td><code>credits_export_cv</code></td>
            </tr>
            <tr>
              <td>Calcul match score</td>
              <td><strong>1</strong></td>
              <td><code>credits_match_score</code></td>
            </tr>
            <tr>
              <td>Traduction CV</td>
              <td><strong>1</strong></td>
              <td><code>credits_translate_cv</code></td>
            </tr>
            <tr>
              <td>G&eacute;n&eacute;ration CV (offre)</td>
              <td><strong>2</strong></td>
              <td><code>credits_gpt_cv_generation</code></td>
            </tr>
            <tr>
              <td>Optimisation CV</td>
              <td><strong>2</strong></td>
              <td><code>credits_optimize_cv</code></td>
            </tr>
            <tr>
              <td>G&eacute;n&eacute;ration depuis titre</td>
              <td><strong>3</strong></td>
              <td><code>credits_generate_cv_from_job_title</code></td>
            </tr>
            <tr>
              <td>Import PDF</td>
              <td><strong>5</strong></td>
              <td><code>credits_import_pdf</code></td>
            </tr>
          </tbody>
        </table>

        <div class="callout callout-warning">
          <div class="callout-title">Changement de mode en production</div>
          <p>Changer de mod&egrave;le en production affecte <strong>imm&eacute;diatement</strong> tous les utilisateurs. Les abonnements Stripe existants restent actifs c&ocirc;t&eacute; Stripe mais les limites ne sont plus appliqu&eacute;es en mode cr&eacute;dits. Il est recommand&eacute; de tester sur l'environnement de pr&eacute;-production (<code>dev.fitmycv.io</code>) avant.</p>
        </div>

        <!-- ==================== DECISION canUseFeature ==================== -->
        <h2>Arbre de D&eacute;cision : <code>canUseFeature()</code></h2>

        <p><strong>Fichier :</strong> <code>lib/subscription/featureUsage.js</code></p>

        <p>Fonction centrale qui d&eacute;termine si un utilisateur peut utiliser une feature. L'arbre de d&eacute;cision diff&egrave;re selon le mode actif :</p>

        <div class="diagram">
          <div class="diagram-title">Arbre de d&eacute;cision complet de canUseFeature()</div>
          <div class="mermaid">
flowchart TD
    Start["canUseFeature(userId, featureName)"]

    BalCheck{"Balance &lt; 0 ?<br/>(chargeback)"}
    ModeCheck{"subscription_mode_enabled ?"}

    subgraph Credits["MODE CRÉDITS-ONLY"]
        CreditCost["getCreditCostForFeature()"]
        CostZero{"cost === 0 ?"}
        CreditSuff{"balance >= cost ?"}
        CreditFree["✅ Feature gratuite<br/>useCredit: false"]
        CreditUse["✅ Utiliser crédits<br/>useCredit: true"]
        CreditBlock["❌ Crédits insuffisants"]
    end

    subgraph Sub["MODE ABONNEMENT"]
        GetSub["getUserSubscriptionWithPlan()"]
        SubActive{"status === 'active' ?"}
        FindLimit["Trouver featureLimit dans plan"]
        PremReq{"premiumRequired ?<br/>(cost === 0)"}
        IsPrem{"Plan Premium ?"}
        Enabled{"featureLimit.isEnabled ?"}
        LimitInf{"usageLimit === -1 ?"}
        Counter["getOrCreateFeatureCounter()"]
        UnderLimit{"count &lt; limit ?"}
        SubCreditSuff{"balance >= cost ?"}
        PremOk["✅ Premium inclus<br/>useCredit: false"]
        PremBlock["❌ Réservé Premium"]
        SubUnlimited["✅ Illimité<br/>useCredit: false"]
        SubOk["✅ Limite non atteinte<br/>useCredit: false"]
        SubCreditUse["✅ Via crédits<br/>useCredit: true"]
        SubBlock["❌ Limite + crédits insuffisants"]
        DisabledCred{"Crédits suffisants ?"}
        DisabledOk["✅ Feature désactivée → crédits"]
        DisabledBlock["❌ Désactivée + insuffisant"]
    end

    Start --> BalCheck
    BalCheck -->|"Oui"| BlockNeg["❌ Balance négative"]
    BalCheck -->|"Non"| ModeCheck

    ModeCheck -->|"false"| CreditCost
    CreditCost --> CostZero
    CostZero -->|"Oui"| CreditFree
    CostZero -->|"Non"| CreditSuff
    CreditSuff -->|"Oui"| CreditUse
    CreditSuff -->|"Non"| CreditBlock

    ModeCheck -->|"true"| GetSub
    GetSub --> SubActive
    SubActive -->|"Non"| SubInactive["❌ Abonnement inactif"]
    SubActive -->|"Oui"| FindLimit
    FindLimit --> PremReq
    PremReq -->|"Oui"| IsPrem
    IsPrem -->|"Oui"| PremOk
    IsPrem -->|"Non"| PremBlock
    PremReq -->|"Non"| Enabled
    Enabled -->|"Non"| DisabledCred
    DisabledCred -->|"Oui"| DisabledOk
    DisabledCred -->|"Non"| DisabledBlock
    Enabled -->|"Oui"| LimitInf
    LimitInf -->|"Oui"| SubUnlimited
    LimitInf -->|"Non"| Counter
    Counter --> UnderLimit
    UnderLimit -->|"Oui"| SubOk
    UnderLimit -->|"Non"| SubCreditSuff
    SubCreditSuff -->|"Oui"| SubCreditUse
    SubCreditSuff -->|"Non"| SubBlock
          </div>
        </div>

        <h3>Code source : canUseFeature() (extrait cl&eacute;)</h3>

        <pre><code class="language-javascript">// lib/subscription/featureUsage.js — Logique duale
export async function canUseFeature(userId, featureName) {
  // 0. Balance négative (chargeback) → BLOQUÉ
  const creditBalance = await getCreditBalance(userId);
  if (creditBalance.balance &lt; 0) return { canUse: false, reason: 'Balance négative' };

  // 0.5 Mode crédits-only ?
  const subscriptionEnabled = await isSubscriptionModeEnabled();

  if (!subscriptionEnabled) {
    // MODE CRÉDITS: cost=0 signifie GRATUIT (pas Premium required)
    const { cost } = await getCreditCostForFeature(featureName);
    if (cost === 0) return { canUse: true, useCredit: false };
    if (creditBalance.balance >= cost)
      return { canUse: true, useCredit: true, creditCost: cost };
    return { canUse: false, reason: 'Crédits insuffisants' };
  }

  // MODE ABONNEMENT: cost=0 signifie Premium required
  const subscription = await getUserSubscriptionWithPlan(userId);
  const featureLimit = subscription.plan.featureLimits.find(/*...*/);
  const { cost, premiumRequired } = await getCreditCostForFeature(featureName);

  // Premium required (cost=0 en mode abo)
  if (premiumRequired) {
    return subscription.plan.name === 'Premium'
      ? { canUse: true, useCredit: false }
      : { canUse: false, reason: 'Réservé Premium' };
  }

  // Feature désactivée → fallback crédits
  if (!featureLimit.isEnabled) {
    return creditBalance.balance >= cost
      ? { canUse: true, useCredit: true }
      : { canUse: false };
  }

  // Limite illimitée ou non atteinte
  if (featureLimit.usageLimit === -1) return { canUse: true };
  const counter = await getOrCreateFeatureCounter(userId, featureName, /*...*/);
  if (counter.count &lt; featureLimit.usageLimit) return { canUse: true };

  // Limite atteinte → fallback crédits
  return creditBalance.balance >= cost
    ? { canUse: true, useCredit: true }
    : { canUse: false };
}</code></pre>

        <h3>Compteurs Mensuels &mdash; Reset Automatique</h3>

        <div class="callout callout-info">
          <div class="callout-title">P&eacute;riode bas&eacute;e sur la date anniversaire</div>
          <p>Les compteurs mensuels (<code>FeatureUsageCounter</code>) utilisent la date anniversaire de l'abonnement, pas le mois calendaire. La fonction <code>getCurrentPeriod(subscription)</code> calcule <code>periodStart</code> et <code>periodEnd</code> &agrave; partir de <code>subscription.currentPeriodStart</code>. Au changement de p&eacute;riode, <code>getOrCreateFeatureCounter()</code> reset automatiquement le compteur &agrave; 0.</p>
        </div>

        <pre><code class="language-javascript">// Reset automatique au changement de période
async function getOrCreateFeatureCounter(userId, featureName, periodStart, periodEnd) {
  let counter = await prisma.featureUsageCounter.findFirst({
    where: { userId, featureName },
  });

  // Si la période a changé → reset le compteur
  if (counter &amp;&amp; counter.periodStart.getTime() !== periodStart.getTime()) {
    return await prisma.featureUsageCounter.update({
      where: { id: counter.id },
      data: { count: 0, periodStart, periodEnd },
    });
  }
  return counter;
}</code></pre>

        <h3>Fonctions Compl&eacute;mentaires</h3>

        <table>
          <thead>
            <tr><th>Fonction</th><th>R&ocirc;le</th><th>SSE</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><code>incrementFeatureCounter()</code></td>
              <td>V&eacute;rifie + incr&eacute;mente + d&eacute;bite cr&eacute;dit si n&eacute;cessaire</td>
              <td>&Eacute;met <code>CreditBalance</code> ou <code>FeatureUsageCounter</code></td>
            </tr>
            <tr>
              <td><code>refundFeatureUsage(taskId)</code></td>
              <td>Rembourse un cr&eacute;dit ou d&eacute;cr&eacute;mente un compteur suite &agrave; &eacute;chec de task</td>
              <td>&Eacute;met <code>credit_refunded</code> ou <code>counter_refunded</code></td>
            </tr>
            <tr>
              <td><code>resetFeatureCounters(userId)</code></td>
              <td>Supprime tous les compteurs (renouvellement abonnement)</td>
              <td>&mdash;</td>
            </tr>
            <tr>
              <td><code>getUserFeatureCounters(userId)</code></td>
              <td>R&eacute;cup&egrave;re tous les compteurs avec limites pour l'UI</td>
              <td>&mdash;</td>
            </tr>
          </tbody>
        </table>

        <!-- ==================== SETTINGS UTILS ==================== -->
        <h2>Utilitaires Settings (<code>settingsUtils.js</code>)</h2>

        <p><strong>Fichier :</strong> <code>lib/settings/settingsUtils.js</code></p>

        <p>Fonctions pour r&eacute;cup&eacute;rer les valeurs de la table <code>Setting</code> avec conversion de type automatique :</p>

        <pre><code class="language-javascript">// Récupère un setting brut (string)
export async function getSettingValue(settingName, defaultValue = null)

// Convertit en nombre (parseInt)
export async function getNumericSettingValue(settingName, defaultValue = 0)

// Convertit en booléen ("1"/"true" → true)
export async function getBooleanSettingValue(settingName, defaultValue = false)

// Raccourci pour le toggle principal
export async function isSubscriptionModeEnabled() {
  return await getBooleanSettingValue('subscription_mode_enabled', true);
  // Défaut: true (mode abonnement actif par défaut)
}</code></pre>

        <div class="callout callout-warning">
          <div class="callout-title">Pas de cache</div>
          <p>Les settings sont lus &agrave; chaque appel depuis la DB (pas de cache). Cela permet de changer le mode &eacute;conomique en temps r&eacute;el via l'interface d'administration sans red&eacute;marrage.</p>
        </div>

        <h2>Fichiers Cl&eacute;s</h2>

        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>R&ocirc;le</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>lib/subscription/featureUsage.js</code></td>
              <td>Logique duale <code>canUseFeature()</code> (abonnement et cr&eacute;dits)</td>
            </tr>
            <tr>
              <td><code>lib/subscription/credits.js</code></td>
              <td>D&eacute;bit, cr&eacute;dit, remboursement, attribution</td>
            </tr>
            <tr>
              <td><code>lib/subscription/creditCost.js</code></td>
              <td>Co&ucirc;ts par feature depuis Settings DB</td>
            </tr>
            <tr>
              <td><code>lib/subscription/subscriptions.js</code></td>
              <td><code>assignDefaultPlan()</code> avec logique duale</td>
            </tr>
            <tr>
              <td><code>lib/settings/settingsUtils.js</code></td>
              <td><code>isSubscriptionModeEnabled()</code></td>
            </tr>
            <tr>
              <td><code>lib/creditCosts/CreditCostsContext.jsx</code></td>
              <td>Provider React centralis&eacute; pour les co&ucirc;ts c&ocirc;t&eacute; client</td>
            </tr>
          </tbody>
        </table>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
