<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D√©ploiement &amp; Infrastructure | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&amp;family=JetBrains+Mono:wght@400;500&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <div id="sidebar-container"></div>
    <main class="main">
      <div id="header-container"></div>
      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <span>D√©ploiement</span>
        </div>

        <h1>D√©ploiement &amp; Infrastructure</h1>
        <p class="lead">
          Architecture Docker multi-stage, pipelines CI/CD GitHub Actions sur runner auto-h√©berg√©, variables d'environnement, health checks et configuration Next.js 16 standalone. Le d√©ploiement couvre deux environnements : pre-prod (<code>dev.fitmycv.io</code>) et production (<code>app.fitmycv.io</code>).
        </p>

        <!-- ==================== ARCHITECTURE DOCKER ==================== -->
        <h2>Architecture Docker</h2>

        <p>Le <code>Dockerfile</code> utilise un build multi-stage en <strong>4 √©tapes</strong> pour optimiser la taille de l'image finale et s√©parer les d√©pendances de build des d√©pendances de production.</p>

        <div class="diagram">
          <div class="diagram-title">Build Docker multi-stage</div>
          <div class="mermaid">
flowchart TB
    subgraph S1["Stage 1 ‚Äî deps"]
        direction TB
        A1["node:20-alpine"]
        A2["apk: libc6-compat, python3, make, g++"]
        A3["npm ci (toutes d√©pendances)"]
        A4["PUPPETEER_SKIP_DOWNLOAD=true"]
        A1 --> A2 --> A3 --> A4
    end

    subgraph S2["Stage 2 ‚Äî production-deps"]
        direction TB
        B1["node:20-alpine"]
        B2["npm ci --omit=dev"]
        B3["D√©pendances de production uniquement"]
        B1 --> B2 --> B3
    end

    subgraph S3["Stage 3 ‚Äî builder"]
        direction TB
        C1["Copie node_modules depuis deps"]
        C2["Copie du code source complet"]
        C3["Injection ARG NEXT_PUBLIC_*"]
        C4["prisma generate"]
        C5["npm run build"]
        C1 --> C2 --> C3 --> C4 --> C5
    end

    subgraph S4["Stage 4 ‚Äî runner"]
        direction TB
        D1["node:20-alpine"]
        D2["apk: chromium, fonts, graphicsmagick, ghostscript"]
        D3["Copie production node_modules"]
        D4["Copie .next/standalone + static + public"]
        D5["Copie prisma/ + scripts/"]
        D6["HEALTHCHECK + CMD node server.js"]
        D1 --> D2 --> D3 --> D4 --> D5 --> D6
    end

    S1 -->|"node_modules"| S3
    S2 -->|"node_modules (prod)"| S4
    S3 -->|".next/standalone + static"| S4
          </div>
        </div>

        <h3>Stage 1 ‚Äî <code>deps</code> (Toutes les d√©pendances)</h3>
        <p>Installe l'ensemble des d√©pendances (build + dev) n√©cessaires √† la compilation. Les packages natifs (<code>python3</code>, <code>make</code>, <code>g++</code>) sont requis pour compiler certains modules Node.js natifs.</p>

        <pre><code class="language-bash">FROM node:20-alpine AS deps
RUN apk add --no-cache libc6-compat python3 make g++
WORKDIR /app
COPY package*.json ./
COPY prisma ./prisma
ENV PUPPETEER_SKIP_DOWNLOAD=true
RUN npm ci</code></pre>

        <h3>Stage 2 ‚Äî <code>production-deps</code> (D√©pendances de production)</h3>
        <p>Stage s√©par√© qui installe uniquement les d√©pendances de production (<code>--omit=dev</code>). Cela permet d'obtenir un <code>node_modules</code> minimal pour l'image finale.</p>

        <pre><code class="language-bash">FROM node:20-alpine AS production-deps
RUN apk add --no-cache python3 make g++
WORKDIR /app
COPY package*.json ./
COPY prisma ./prisma
ENV DATABASE_URL="postgresql://dummy:dummy@localhost:5432/dummy"
ENV PUPPETEER_SKIP_DOWNLOAD=true
RUN npm ci --omit=dev</code></pre>

        <div class="callout callout-info">
          <strong>DATABASE_URL dummy</strong> ‚Äî Une URL factice est fournie car Prisma valide la variable lors du <code>postinstall</code>. La vraie URL sera inject√©e au runtime via Docker Compose.
        </div>

        <h3>Stage 3 ‚Äî <code>builder</code> (Compilation)</h3>
        <p>Compile l'application Next.js en mode production. Les variables <code>NEXT_PUBLIC_*</code> sont inject√©es comme <code>ARG</code> Docker car Next.js les int√®gre (bake) dans le JavaScript client au moment du build.</p>

        <table>
          <thead>
            <tr>
              <th>Build ARG</th>
              <th>Usage</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>NEXT_PUBLIC_RECAPTCHA_SITE_KEY</code></td>
              <td>Cl√© publique reCAPTCHA v3 pour le frontend</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY</code></td>
              <td>Cl√© publique Stripe pour le checkout c√¥t√© client</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_SITE_URL</code></td>
              <td>URL publique du site (ex: <code>https://app.fitmycv.io</code>)</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_APP_URL</code></td>
              <td>URL de l'application (identique √† SITE_URL en production)</td>
            </tr>
          </tbody>
        </table>

        <h3>Stage 4 ‚Äî <code>runner</code> (Image finale)</h3>
        <p>L'image de production embarque les outils syst√®me n√©cessaires au fonctionnement de l'application :</p>

        <table>
          <thead>
            <tr>
              <th>Package</th>
              <th>R√¥le</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>chromium</code></td>
              <td>Navigateur headless pour Puppeteer (export PDF des CV + extraction d'URL)</td>
            </tr>
            <tr>
              <td><code>font-noto</code>, <code>font-freefont</code></td>
              <td>Polices pour le rendu correct des PDF avec Chromium</td>
            </tr>
            <tr>
              <td><code>graphicsmagick</code></td>
              <td>Conversion PDF ‚Üí images lors de l'import de CV (via <code>pdf2pic</code>)</td>
            </tr>
            <tr>
              <td><code>ghostscript</code></td>
              <td>Backend de rendu PDF pour GraphicsMagick</td>
            </tr>
            <tr>
              <td><code>openssl</code></td>
              <td>Requis par Prisma pour les connexions SSL √† PostgreSQL</td>
            </tr>
          </tbody>
        </table>

        <div class="callout callout-warning">
          <strong>Puppeteer</strong> ‚Äî La variable <code>PUPPETEER_EXECUTABLE_PATH=/usr/bin/chromium-browser</code> force Puppeteer √† utiliser le Chromium syst√®me au lieu de t√©l√©charger sa propre version, ce qui r√©duit la taille de l'image.
        </div>

        <p>L'image finale copie 5 √©l√©ments depuis les stages pr√©c√©dents :</p>

        <pre><code class="language-bash"># 1. Production node_modules (Prisma CLI, stripe, etc.)
COPY --from=production-deps /app/node_modules ./node_modules

# 2. Next.js standalone server
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static
COPY --from=builder /app/public ./public

# 3. Prisma (schema + migrations + data-migrations)
COPY --from=builder /app/prisma ./prisma

# 4. Post-deploy scripts (migrations runner, stripe sync)
COPY --from=builder /app/scripts ./scripts

# 5. package.json (needed for npm run scripts)
COPY --from=builder /app/package.json ./package.json</code></pre>

        <!-- ==================== HEALTH CHECK ==================== -->
        <h2>Health Check</h2>

        <p>Le conteneur Docker embarque un health check natif qui interroge l'endpoint <code>/api/health</code> :</p>

        <pre><code class="language-bash">HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
  CMD node -e "fetch('http://localhost:'+(process.env.PORT||3000)+'/api/health') \
    .then(r=>{if(r.ok)process.exit(0);else process.exit(1)}) \
    .catch(()=>process.exit(1))"</code></pre>

        <table>
          <thead>
            <tr>
              <th>Param√®tre</th>
              <th>Valeur</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>interval</code></td>
              <td>30s</td>
              <td>Fr√©quence de v√©rification</td>
            </tr>
            <tr>
              <td><code>timeout</code></td>
              <td>10s</td>
              <td>Temps max d'attente de la r√©ponse</td>
            </tr>
            <tr>
              <td><code>start-period</code></td>
              <td>40s</td>
              <td>D√©lai de gr√¢ce au d√©marrage du conteneur</td>
            </tr>
            <tr>
              <td><code>retries</code></td>
              <td>3</td>
              <td>√âchecs cons√©cutifs avant de marquer le conteneur <code>unhealthy</code></td>
            </tr>
          </tbody>
        </table>

        <!-- ==================== CI/CD PIPELINES ==================== -->
        <h2>Pipelines CI/CD</h2>

        <p>Deux workflows GitHub Actions g√®rent le cycle de vie complet du d√©ploiement sur un <strong>runner auto-h√©berg√©</strong>. Le runner a un acc√®s direct √† la machine de production, ce qui permet des op√©rations Docker et base de donn√©es locales.</p>

        <div class="diagram">
          <div class="diagram-title">Vue d'ensemble des pipelines CI/CD</div>
          <div class="mermaid">
flowchart LR
    subgraph PR["Pull Request vers main"]
        direction TB
        CI["CI: npm ci + build + audit"]
        CD["CD: Docker build + deploy staging"]
        DB["Clone DB prod ‚Üí staging"]
        Stripe["Sync Stripe test"]
        CI --> CD --> DB --> Stripe
    end

    subgraph Merge["Merge sur main"]
        direction TB
        Version["Versioning automatique"]
        Build["Docker build production"]
        Deploy["Deploy + health check"]
        Migrate["Prisma + data migrations"]
        Sync["Sync branches dev/release"]
        Version --> Build --> Deploy --> Migrate
        Version --> Sync
    end

    subgraph Close["Fermeture PR"]
        direction TB
        Stop["Stop conteneur staging"]
        Drop["Drop DB fitmycv_release"]
        Stop --> Drop
    end

    PR -->|"merge"| Merge
    PR -->|"close"| Close
          </div>
        </div>

        <!-- ===== PREPROD ===== -->
        <h3>Pipeline Pre-prod (<code>preprod.yml</code>)</h3>

        <p>D√©clench√© sur chaque <strong>Pull Request vers <code>main</code></strong> (opened, synchronize, reopened, closed). Comprend 3 jobs :</p>

        <h4>Job 1 ‚Äî CI (Validation du build)</h4>
        <p>V√©rifie que l'application compile correctement sans Docker :</p>

        <pre><code class="language-yaml">ci:
  if: github.event.action != 'closed'
  steps:
    - npm ci
    - cp .env.example .env && npx prisma generate
    - npm run build  # NODE_ENV=production
    - npm audit --audit-level=critical || true</code></pre>

        <h4>Job 2 ‚Äî Deploy Preview (Staging)</h4>
        <p>D√©ploie l'application sur <code>dev.fitmycv.io</code> (port 3001) avec une base de donn√©es clon√©e depuis la production :</p>

        <ol>
          <li><strong>Clone DB</strong> ‚Äî <code>pg_dump fitmycv_prod</code> ‚Üí <code>fitmycv_release</code> (uniquement √† l'ouverture de la PR)</li>
          <li><strong>Sanitize</strong> ‚Äî Supprime toutes les r√©f√©rences Stripe Live pour √©viter les op√©rations accidentelles sur les donn√©es de paiement r√©elles</li>
          <li><strong>Docker Build</strong> ‚Äî Build avec les cl√©s publiques de staging</li>
          <li><strong>Deploy</strong> ‚Äî <code>docker compose -p fitmycv-staging up -d</code></li>
          <li><strong>Health Check</strong> ‚Äî Attend jusqu'√† 150s (30 tentatives √ó 5s) que l'application r√©ponde</li>
          <li><strong>Migrations</strong> ‚Äî <code>prisma migrate deploy</code> + <code>run-data-migrations.js</code></li>
          <li><strong>Stripe Sync</strong> ‚Äî Synchronise les produits et coupons depuis Stripe Live vers Stripe Test</li>
        </ol>

        <div class="callout callout-warning">
          <strong>Sanitization de la base de donn√©es</strong> ‚Äî Les champs <code>stripeCustomerId</code>, <code>stripeSubscriptionId</code> et <code>stripePriceId</code> sont effac√©s ou remplac√©s par des pr√©fixes <code>staging_</code> pour √©viter toute interaction avec l'API Stripe en mode live.
        </div>

        <pre><code class="language-sql">-- Sanitization des donn√©es Stripe lors du clone staging
UPDATE "User" SET "stripeCustomerId" = NULL;
UPDATE "Subscription" SET
  "stripeCustomerId" = 'staging_' || "id",
  "stripeSubscriptionId" = NULL,
  "stripePriceId" = NULL,
  "status" = 'canceled';</code></pre>

        <h4>Job 3 ‚Äî Cleanup (Fermeture PR)</h4>
        <p>Nettoyage automatique lorsque la PR est ferm√©e (merge ou rejet) :</p>

        <pre><code class="language-yaml">cleanup:
  if: github.event.action == 'closed'
  steps:
    - docker compose -p fitmycv-staging down
    - docker rm -f fitmycv-preview
    - dropdb --if-exists fitmycv_release</code></pre>

        <!-- ===== PROD ===== -->
        <h3>Pipeline Production (<code>prod.yml</code>)</h3>

        <p>D√©clench√© sur chaque <strong>push sur <code>main</code></strong> (apr√®s merge d'une PR). Ex√©cute les √©tapes suivantes dans un seul job :</p>

        <div class="diagram">
          <div class="diagram-title">Pipeline de d√©ploiement production</div>
          <div class="mermaid">
flowchart TB
    A["Push sur main"] --> B["Checkout (fetch-depth: 0)"]
    B --> C["Versioning automatique"]
    C --> D["git tag vX.X.X.X + push"]
    D --> E["Sync branche dev"]
    E --> F["Extract Public Config"]
    F --> G["Docker Build"]
    G --> H["docker compose up -d"]
    H --> I["Health Check (30 √ó 5s)"]
    I -->|"‚úÖ OK"| J["Prisma migrate deploy"]
    I -->|"‚ùå Fail"| K["docker logs + exit 1"]
    J --> L["Data migrations"]
          </div>
        </div>

        <h4>1. Versioning automatique</h4>
        <p>Le script <code>scripts/bump-version.sh</code> analyse les messages de commit de la PR et incr√©mente la version selon les <strong>Conventional Commits</strong> (voir CLAUDE.md pour le d√©tail des r√®gles).</p>

        <pre><code class="language-bash"># Ex√©cut√© automatiquement dans le pipeline
./scripts/bump-version.sh "$COMMIT_MESSAGE"
NEW_VERSION=$(node -p "require('./package.json').version")
git add . && git commit -m "chore(release): v$NEW_VERSION [skip ci]"
git tag "v$NEW_VERSION"
git push origin main --tags</code></pre>

        <div class="callout callout-info">
          <strong>[skip ci]</strong> ‚Äî Le commit de versioning utilise <code>[skip ci]</code> dans son message pour √©viter de d√©clencher une boucle infinie de d√©ploiements.
        </div>

        <h4>2. Synchronisation des branches</h4>
        <p>Apr√®s le versioning, la branche <code>dev</code> est automatiquement synchronis√©e avec <code>main</code> pour que toutes les branches de travail h√©ritent de la nouvelle version.</p>

        <h4>3. Build &amp; Deploy</h4>
        <p>Les variables publiques sont extraites depuis le fichier <code>.env</code> du serveur de production et inject√©es comme <code>--build-arg</code> Docker :</p>

        <pre><code class="language-bash">docker build \
  --build-arg NEXT_PUBLIC_RECAPTCHA_SITE_KEY="$RECAPTCHA_KEY" \
  --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="$STRIPE_PK" \
  --build-arg NEXT_PUBLIC_SITE_URL="$APP_URL" \
  --build-arg NEXT_PUBLIC_APP_URL="$APP_URL" \
  -t fitmycv:latest .</code></pre>

        <h4>4. Health check post-deploy</h4>
        <p>Apr√®s le d√©ploiement, le pipeline attend que l'application soit pr√™te avant de lancer les migrations. La boucle effectue <strong>30 tentatives</strong> espac√©es de <strong>5 secondes</strong> (150s max) :</p>

        <pre><code class="language-bash">for i in $(seq 1 30); do
  if docker exec fitmycv-prod node -e \
    "fetch('http://localhost:'+(process.env.PORT||3000)+'/api/health') \
     .then(r=>{if(r.ok)process.exit(0);else process.exit(1)}) \
     .catch(()=>process.exit(1))" 2>/dev/null; then
    echo "‚úÖ Application is ready!"
    exit 0
  fi
  sleep 5
done</code></pre>

        <h4>5. Migrations post-deploy</h4>
        <p>Une fois le health check pass√©, les migrations sont ex√©cut√©es <strong>√† l'int√©rieur du conteneur</strong> :</p>

        <pre><code class="language-bash"># Migrations de sch√©ma Prisma
docker exec fitmycv-prod npx prisma migrate deploy

# Migrations de donn√©es (scripts JS dans prisma/data-migrations/)
docker exec fitmycv-prod node scripts/run-data-migrations.js</code></pre>

        <!-- ==================== VARIABLES D'ENVIRONNEMENT ==================== -->
        <h2>Variables d'environnement</h2>

        <p>Toutes les variables d√©finies dans <code>.env.example</code> :</p>

        <table>
          <thead>
            <tr>
              <th>Variable</th>
              <th>Cat√©gorie</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>DATABASE_URL</code></td>
              <td>Base de donn√©es</td>
              <td>URL de connexion PostgreSQL</td>
            </tr>
            <tr>
              <td><code>NODE_ENV</code></td>
              <td>Runtime</td>
              <td><code>production</code> ou <code>development</code></td>
            </tr>
            <tr>
              <td><code>PORT</code></td>
              <td>Runtime</td>
              <td>Port d'√©coute (3000 en prod, 3001 en staging)</td>
            </tr>
            <tr>
              <td><code>NEXTAUTH_SECRET</code></td>
              <td>Auth</td>
              <td>Cl√© secr√®te pour le chiffrement des sessions NextAuth</td>
            </tr>
            <tr>
              <td><code>NEXTAUTH_URL</code></td>
              <td>Auth</td>
              <td>URL canonique de l'application pour NextAuth</td>
            </tr>
            <tr>
              <td><code>NEXTAUTH_URL_INTERNAL</code></td>
              <td>Auth</td>
              <td>URL interne (identique en production, peut diff√©rer derri√®re un reverse proxy)</td>
            </tr>
            <tr>
              <td><code>OPENAI_API_KEY</code></td>
              <td>IA</td>
              <td>Cl√© API OpenAI pour la g√©n√©ration/optimisation de CV</td>
            </tr>
            <tr>
              <td><code>EMAIL_PROVIDER</code></td>
              <td>Email</td>
              <td>Provider : <code>auto</code> (SMTP + Resend fallback), <code>smtp</code>, ou <code>resend</code></td>
            </tr>
            <tr>
              <td><code>EMAIL_FROM</code></td>
              <td>Email</td>
              <td>Adresse d'exp√©dition (ex: <code>FitMyCV &lt;noreply@fitmycv.io&gt;</code>)</td>
            </tr>
            <tr>
              <td><code>TRUSTPILOT_INVITE_EMAIL</code></td>
              <td>Email</td>
              <td>BCC Trustpilot sur les emails de confirmation d'achat</td>
            </tr>
            <tr>
              <td><code>SMTP_HOST</code></td>
              <td>Email / SMTP</td>
              <td>H√¥te SMTP OVH (<code>ssl0.ovh.net</code> mutualis√©, <code>pro1.mail.ovh.net</code> Pro)</td>
            </tr>
            <tr>
              <td><code>SMTP_PORT</code></td>
              <td>Email / SMTP</td>
              <td>Port SMTP (587 pour STARTTLS)</td>
            </tr>
            <tr>
              <td><code>SMTP_SECURE</code></td>
              <td>Email / SMTP</td>
              <td>Connexion SSL directe (<code>false</code> pour STARTTLS)</td>
            </tr>
            <tr>
              <td><code>SMTP_USER</code> / <code>SMTP_PASSWORD</code></td>
              <td>Email / SMTP</td>
              <td>Identifiants SMTP</td>
            </tr>
            <tr>
              <td><code>RESEND_API_KEY</code></td>
              <td>Email / Resend</td>
              <td>Cl√© API Resend (provider de fallback)</td>
            </tr>
            <tr>
              <td><code>GOOGLE_CLIENT_ID</code> / <code>GOOGLE_CLIENT_SECRET</code></td>
              <td>OAuth</td>
              <td>Identifiants OAuth Google</td>
            </tr>
            <tr>
              <td><code>GITHUB_ID</code> / <code>GITHUB_SECRET</code></td>
              <td>OAuth</td>
              <td>Identifiants OAuth GitHub</td>
            </tr>
            <tr>
              <td><code>APPLE_CLIENT_ID</code> / <code>APPLE_CLIENT_SECRET</code></td>
              <td>OAuth</td>
              <td>Identifiants OAuth Apple</td>
            </tr>
            <tr>
              <td><code>APPLE_KEY_ID</code> / <code>APPLE_TEAM_ID</code></td>
              <td>OAuth</td>
              <td>Configuration Sign in with Apple</td>
            </tr>
            <tr>
              <td><code>CV_ENCRYPTION_KEY</code></td>
              <td>S√©curit√©</td>
              <td>Cl√© AES pour le chiffrement des CV au repos (base64, 32 octets)</td>
            </tr>
            <tr>
              <td><code>CRON_SECRET</code></td>
              <td>S√©curit√©</td>
              <td>Secret pour l'authentification des cron jobs internes</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_RECAPTCHA_SITE_KEY</code></td>
              <td>reCAPTCHA</td>
              <td>Cl√© publique reCAPTCHA v3 (inject√©e au build)</td>
            </tr>
            <tr>
              <td><code>RECAPTCHA_SECRET_KEY</code></td>
              <td>reCAPTCHA</td>
              <td>Cl√© secr√®te reCAPTCHA v3 (v√©rification c√¥t√© serveur)</td>
            </tr>
            <tr>
              <td><code>BYPASS_RECAPTCHA</code></td>
              <td>reCAPTCHA</td>
              <td>D√©sactive la v√©rification reCAPTCHA (<code>false</code> en production)</td>
            </tr>
            <tr>
              <td><code>STRIPE_SECRET_KEY</code></td>
              <td>Stripe</td>
              <td>Cl√© secr√®te Stripe (pr√©fixe <code>sk_test_</code> ou <code>sk_live_</code>)</td>
            </tr>
            <tr>
              <td><code>STRIPE_WEBHOOK_SECRET</code></td>
              <td>Stripe</td>
              <td>Secret de signature des webhooks Stripe</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY</code></td>
              <td>Stripe</td>
              <td>Cl√© publique Stripe (inject√©e au build)</td>
            </tr>
            <tr>
              <td><code>STRIPE_INVOICE_TEMPLATE_ID</code></td>
              <td>Stripe</td>
              <td>Template de rendu des factures Stripe</td>
            </tr>
            <tr>
              <td><code>NEXT_PUBLIC_SITE_URL</code></td>
              <td>App</td>
              <td>URL publique du site (inject√©e au build)</td>
            </tr>
          </tbody>
        </table>

        <div class="callout callout-warning">
          <strong>Variables NEXT_PUBLIC_*</strong> ‚Äî Ces variables sont int√©gr√©es dans le JavaScript client au moment du <code>docker build</code>. Elles ne peuvent pas √™tre chang√©es au runtime sans reconstruire l'image Docker.
        </div>

        <!-- ==================== CONFIGURATION NEXT.JS ==================== -->
        <h2>Configuration Next.js</h2>

        <p>Le fichier <code>next.config.js</code> configure Next.js 16 pour le d√©ploiement en mode standalone :</p>

        <pre><code class="language-javascript">const nextConfig = {
  // Mode standalone pour Docker (g√©n√®re un serveur autonome)
  output: 'standalone',

  // Version et nom du site inject√©s comme variables d'env
  env: {
    NEXT_PUBLIC_APP_VERSION: version,  // Depuis package.json
    NEXT_PUBLIC_SITE_NAME: "FitMyCV.io",
  },

  // Optimisation des images (AVIF + WebP)
  images: {
    formats: ['image/avif', 'image/webp'],
    minimumCacheTTL: 60,
  },

  // Compression activ√©e
  compress: true,

  // Next.js 16 : Turbopack est le bundler par d√©faut
  turbopack: {},

  // Packages serveur non bundl√©s (Puppeteer)
  serverExternalPackages: [
    'puppeteer', 'puppeteer-extra', 'puppeteer-extra-plugin-stealth'
  ],

  // Optimisation des imports de packages
  experimental: {
    optimizePackageImports: ['lucide-react', 'next-auth'],
  },
};</code></pre>

        <table>
          <thead>
            <tr>
              <th>Option</th>
              <th>Valeur</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>output</code></td>
              <td><code>'standalone'</code></td>
              <td>G√©n√®re un serveur Node.js autonome avec uniquement les fichiers n√©cessaires, optimal pour Docker</td>
            </tr>
            <tr>
              <td><code>turbopack</code></td>
              <td><code>{}</code></td>
              <td>Active Turbopack, le bundler par d√©faut de Next.js 16 (remplace Webpack)</td>
            </tr>
            <tr>
              <td><code>compress</code></td>
              <td><code>true</code></td>
              <td>Active la compression gzip/brotli des r√©ponses</td>
            </tr>
            <tr>
              <td><code>serverExternalPackages</code></td>
              <td>Puppeteer</td>
              <td>Exclut Puppeteer du bundling c√¥t√© serveur (binaire natif)</td>
            </tr>
            <tr>
              <td><code>allowedDevOrigins</code></td>
              <td><code>['dev.fitmycv.io']</code></td>
              <td>Autorise les requ√™tes cross-origin en d√©veloppement depuis le domaine de staging</td>
            </tr>
            <tr>
              <td><code>transpilePackages</code></td>
              <td><code>['swiper']</code></td>
              <td>Compile Swiper pour compatibilit√© avec le bundler</td>
            </tr>
            <tr>
              <td><code>optimizePackageImports</code></td>
              <td><code>lucide-react</code>, <code>next-auth</code></td>
              <td>Tree-shaking optimis√© pour ces librairies volumineuses</td>
            </tr>
          </tbody>
        </table>

        <h3>Webpack ‚Äî Split Chunks (mode legacy)</h3>
        <p>La configuration Webpack est conserv√©e pour compatibilit√© avec le flag <code>--webpack</code> mais est <strong>ignor√©e par Turbopack</strong> (bundler par d√©faut en Next.js 16). Elle d√©finit 4 groupes de cache :</p>

        <table>
          <thead>
            <tr>
              <th>Cache Group</th>
              <th>Priorit√©</th>
              <th>Contenu</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>framework</code></td>
              <td>40</td>
              <td>React, React DOM, Scheduler, Next.js</td>
            </tr>
            <tr>
              <td><code>auth</code></td>
              <td>35</td>
              <td>NextAuth.js</td>
            </tr>
            <tr>
              <td><code>lib</code></td>
              <td>30</td>
              <td>Tous les autres <code>node_modules</code></td>
            </tr>
            <tr>
              <td><code>commons</code></td>
              <td>20</td>
              <td>Modules partag√©s entre 2+ chunks</td>
            </tr>
          </tbody>
        </table>

        <!-- ==================== PROCESSUS COMPLET ==================== -->
        <h2>Processus de d√©ploiement complet</h2>

        <div class="diagram">
          <div class="diagram-title">Cycle de vie d'un d√©ploiement FitMyCV</div>
          <div class="mermaid">
flowchart TB
    Dev["D√©veloppeur push sur dev"] --> PR["Ouvre PR vers main"]
    PR --> CI["CI: Build validation"]
    CI --> Staging["Deploy sur dev.fitmycv.io"]
    Staging --> Clone["Clone DB prod ‚Üí staging"]
    Clone --> Test["Tests manuels sur staging"]
    Test -->|"Approuv√©"| Merge["Merge PR dans main"]
    Test -->|"Rejet√©"| Close["Close PR"]
    Close --> Cleanup["Cleanup: stop container + drop DB"]
    Merge --> Version["Bump version automatique"]
    Version --> Tag["Git tag vX.X.X.X"]
    Tag --> Build["Docker build production"]
    Build --> Deploy["docker compose up -d"]
    Deploy --> Health["Health check (150s max)"]
    Health -->|"‚úÖ"| Migrations["Prisma + data migrations"]
    Health -->|"‚ùå"| Fail["Logs + √©chec pipeline"]
    Migrations --> Live["üöÄ En production"]
    Version --> SyncDev["Sync branche dev"]
          </div>
        </div>

        <!-- ==================== FICHIERS CL√âS ==================== -->
        <h2>Fichiers cl√©s</h2>

        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>R√¥le</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Dockerfile</code></td>
              <td>Build multi-stage Docker (4 √©tapes)</td>
            </tr>
            <tr>
              <td><code>.github/workflows/prod.yml</code></td>
              <td>Pipeline de d√©ploiement production (push sur main)</td>
            </tr>
            <tr>
              <td><code>.github/workflows/preprod.yml</code></td>
              <td>Pipeline pre-prod (cycle de vie PR : CI + staging + cleanup)</td>
            </tr>
            <tr>
              <td><code>.env.example</code></td>
              <td>Template de toutes les variables d'environnement requises</td>
            </tr>
            <tr>
              <td><code>next.config.js</code></td>
              <td>Configuration Next.js 16 (standalone, Turbopack, images, Puppeteer)</td>
            </tr>
            <tr>
              <td><code>scripts/bump-version.sh</code></td>
              <td>Script de versioning automatique (Conventional Commits ‚Üí 4 parties)</td>
            </tr>
            <tr>
              <td><code>scripts/run-data-migrations.js</code></td>
              <td>Runner des migrations de donn√©es post-deploy</td>
            </tr>
          </tbody>
        </table>

      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
