<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Patterns & Conventions | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">

  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <!-- Sidebar injectée par layout.js -->
    <div id="sidebar-container"></div>

    <!-- Main Content -->
    <main class="main">
      <!-- Header injecté par layout.js -->
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Architecture</a>
          <span>/</span>
          <span>Patterns</span>
        </div>

        <h1>Patterns & Conventions</h1>
        <p class="lead">
          Patterns de code et conventions utilisés dans FitMyCV.io pour garantir cohérence et maintenabilité.
        </p>

        <h2>Pattern API Route</h2>

        <p>Toutes les 123 API Routes suivent une structure standardisée :</p>

        <pre><code class="language-javascript">// app/api/example/route.js
import { auth } from '@/lib/auth/session';
import prisma from '@/lib/prisma';
import { CommonErrors } from '@/lib/api/apiErrors';

export async function GET(request) {
  try {
    // 1. Authentification (via NextAuth 4)
    const session = await auth();
    if (!session?.user?.id) {
      return CommonErrors.notAuthenticated();
    }

    // 2. Extraction paramètres
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    // 3. Logique métier
    const data = await prisma.example.findUnique({
      where: { id, userId: session.user.id }
    });

    if (!data) {
      return CommonErrors.notFound('Example');
    }

    // 4. Réponse
    return Response.json({ data });

  } catch (error) {
    console.error('[API] Example error:', error);
    return CommonErrors.serverError();
  }
}

export async function POST(request) {
  try {
    const session = await auth();
    if (!session?.user?.id) {
      return CommonErrors.notAuthenticated();
    }

    const body = await request.json();

    const created = await prisma.example.create({
      data: { ...body, userId: session.user.id }
    });

    return Response.json({ data: created }, { status: 201 });

  } catch (error) {
    return CommonErrors.serverError();
  }
}</code></pre>

        <h2>Pattern Gestion d'Erreurs i18n</h2>

        <p>Les erreurs API utilisent des clés de traduction i18n au lieu de messages bruts. Cela permet aux clients de localiser les messages d'erreur.</p>

        <div class="diagram">
          <div class="diagram-title">Architecture des erreurs API par domaine</div>
          <div class="mermaid">
flowchart TB
    subgraph Factory["Fabrique d'erreurs API"]
        direction TB
        Key["Clé i18n"]
        Status["HTTP Status"]
        Params["Params dynamiques"]
        Action["Action requise +<br/>URL de redirection"]
    end

    subgraph Domains["DOMAINES D'ERREURS"]
        Common["Erreurs communes<br/>Auth, 404, Serveur,<br/>Accès refusé, Payload"]
        Auth["Authentification<br/>Email, Token, Mot de passe,<br/>OAuth, Inscription"]
        Cv["Erreurs CV<br/>Introuvable, Nom invalide,<br/>Lecture, Amélioration"]
        Sub["Abonnement<br/>Limite atteinte, Plan invalide,<br/>Erreur paiement"]
        Bg["Tâches arrière-plan<br/>Source manquante,<br/>Erreur file d'attente"]
        Ext["Extension<br/>Identifiants invalides,<br/>CV source introuvable"]
        Acct["Compte utilisateur<br/>Mise à jour, Mot de passe,<br/>Suppression, Dissociation"]
        Other["Autres erreurs<br/>Feedback, Export PDF,<br/>Consentement"]
    end

    Factory --> Domains

    style Key fill:#64748b,stroke:#475569,color:#fff
    style Status fill:#64748b,stroke:#475569,color:#fff
    style Params fill:#64748b,stroke:#475569,color:#fff
    style Action fill:#64748b,stroke:#475569,color:#fff
    style Common fill:#0ea5e9,stroke:#0284c7,color:#fff
    style Auth fill:#6366f1,stroke:#4f46e5,color:#fff
    style Cv fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style Sub fill:#f59e0b,stroke:#d97706,color:#fff
    style Bg fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style Ext fill:#6366f1,stroke:#4f46e5,color:#fff
    style Acct fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style Other fill:#64748b,stroke:#475569,color:#fff
          </div>
        </div>

        <pre><code class="language-javascript">// lib/api/apiErrors.js - Factory avec clés i18n

export function apiError(translationKey, options = {}) {
  const { params = {}, actionRequired = false, redirectUrl = null, status = 400 } = options;

  const response = {
    error: translationKey,              // Ex: 'errors.api.auth.emailRequired'
    ...(Object.keys(params).length > 0 && { params }),
    ...(actionRequired && { actionRequired }),
    ...(redirectUrl && { redirectUrl })
  };

  return NextResponse.json(response, { status });
}

// Erreurs pré-définies par domaine
export const CommonErrors = {
  notAuthenticated: (opts) => apiError('errors.api.common.notAuthenticated', { status: 401, ...opts }),
  notFound: (resource, opts) => apiError('errors.api.common.notFound', { params: { resource }, status: 404, ...opts }),
  forbidden: (opts) => apiError('errors.api.common.forbidden', { status: 403, ...opts }),
  serverError: (opts) => apiError('errors.api.common.serverError', { status: 500, ...opts }),
  invalidPayload: (opts) => apiError('errors.api.common.invalidPayload', { status: 400, ...opts }),
};

// Erreurs avec redirection (upgrade abonnement)
export const SubscriptionErrors = {
  limitReached: (feature) => apiError('errors.api.subscription.limitReached', {
    params: { feature },
    actionRequired: true,
    redirectUrl: '/subscription'
  }),
};</code></pre>

        <h2>Pattern Feature Usage</h2>

        <p>Vérification des limites et débit de crédits avant chaque action payante :</p>

        <pre><code class="language-javascript">// Pattern complet de vérification feature
import { canUseFeature, incrementFeatureCounter } from '@/lib/subscription/featureUsage';
import { debitCredit, refundCredit } from '@/lib/subscription/credits';

export async function POST(request) {
  const session = await auth();
  const userId = session.user.id;
  const featureName = 'gpt_cv_generation';

  // 1. Vérifier si l'utilisateur peut utiliser la feature
  const {
    canUse,
    useCredit,
    reason,
    creditCost
  } = await canUseFeature(userId, featureName);

  if (!canUse) {
    return SubscriptionErrors.limitReached(featureName);
  }

  // 2. Débiter le crédit si nécessaire (AVANT l'action)
  let creditTransactionId = null;
  if (useCredit) {
    const { success, transaction } = await debitCredit(userId, creditCost, 'usage', { featureName });
    creditTransactionId = transaction.id;
  }

  try {
    // 3. Exécuter l'action
    const result = await performAction();

    // 4. Incrémenter le compteur (mode abonnement)
    if (!useCredit) {
      await incrementFeatureCounter(userId, featureName);
    }

    return Response.json({ data: result });

  } catch (error) {
    // 5. Rembourser en cas d'échec
    if (creditTransactionId) {
      await refundCredit(userId, creditTransactionId, 'Action failed');
    }
    throw error;
  }
}</code></pre>

        <h2>Pattern CV Operations</h2>

        <pre><code class="language-javascript">// Lecture/Écriture CV en base de données
import { readUserCvFile, writeUserCvFile, listUserCvFiles } from '@/lib/cv-core/storage';
import { validateCv } from '@/lib/cv-core/validation';

// Lire un CV (contenu JSON depuis CvFile.content)
const cvData = await readUserCvFile(userId, filename);
// cvData = { header, sections, metadata }

// Valider un CV
const { valid, errors } = validateCv(cvData);

// Modifier et sauvegarder (incrémente contentVersion)
cvData.sections.experiences[0].title = 'Nouveau titre';
await writeUserCvFile(userId, filename, cvData);

// Lister tous les CV d'un utilisateur
const cvFiles = await listUserCvFiles(userId);
// [{ filename, createdAt, matchScore, language, ... }]</code></pre>

        <h2>Pattern Background Jobs</h2>

        <div class="diagram">
          <div class="diagram-title">Cycle de vie d'une tâche asynchrone</div>
          <div class="mermaid">
flowchart TD
    START(("*")) -->|"Creation tache"| pending["En attente"]
    pending -->|"Demarrage du job"| running["En cours"]
    running -->|"Succes"| completed["Termine"]
    running -->|"Echec"| failed["En echec"]
    failed -->|"Nouvel essai (max 3)"| running
    completed --> END(("*"))
    failed -->|"Maximum atteint"| END

    style START fill:#0ea5e9,stroke:#0284c7,color:#fff
    style pending fill:#f59e0b,stroke:#d97706,color:#fff
    style running fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style completed fill:#22c55e,stroke:#16a34a,color:#fff
    style failed fill:#ef4444,stroke:#dc2626,color:#fff
    style END fill:#64748b,stroke:#475569,color:#fff
          </div>
        </div>

        <pre><code class="language-javascript">// Création et enqueue d'une tâche
import { enqueueJob } from '@/lib/background-jobs/jobQueue';

// 1. Créer la tâche en base (tracking)
const task = await prisma.backgroundTask.create({
  data: {
    id: taskId,
    title: 'Génération CV',
    type: 'cv_generation',
    status: 'pending',
    userId,
    deviceId,
  }
});

// 2. Enqueue le job (géré par processRegistry)
enqueueJob(() => startGeneration(task.id));

// Le job met à jour le status en base :
// pending -> running -> completed/failed</code></pre>

        <h2>Pattern OpenAI Structured Output</h2>

        <pre><code class="language-javascript">// Appel OpenAI avec JSON Schema validé par ajv
import { getOpenAIClient, getCvModel } from '@/lib/openai-core/client';
import { loadSchema } from '@/lib/openai-core/schemaLoader';
import { loadPrompt } from '@/lib/openai-core/promptLoader';

const schema = await loadSchema('cv-adaptation/batch-experience-output');
const prompt = await loadPrompt('cv-adaptation/batch-experience');
const model = await getCvModel();

// Obtenir le client OpenAI (singleton avec clé API)
const client = getOpenAIClient();

const response = await client.responses.create({
  model,
  input: [
    { role: 'system', content: prompt },
    { role: 'user', content: JSON.stringify(inputData) }
  ],
  text: {
    format: {
      type: 'json_schema',
      name: 'batch_experience_output',
      schema: schema,
      strict: true
    }
  }
});

// response.output_text = JSON validé selon le schema
// Tokens et coûts loggés via lib/openai-core/tracking</code></pre>

        <h2>Pattern SSE Progress</h2>

        <pre><code class="language-javascript">// Envoi de progression en temps réel via Server-Sent Events
// app/api/events/stream/route.js
import { dbEmitter } from '@/lib/events/dbEmitter';

export async function GET(request) {
  const { searchParams } = new URL(request.url);
  const deviceId = searchParams.get('deviceId');

  const stream = new ReadableStream({
    start(controller) {
      const encoder = new TextEncoder();

      const sendEvent = (data) => {
        controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`));
      };

      // Écouter les événements DB pour ce device
      const listener = (event) => {
        if (event.deviceId === deviceId) {
          sendEvent(event);
        }
      };

      dbEmitter.on('task-update', listener);

      // Cleanup à la déconnexion
      request.signal.addEventListener('abort', () => {
        dbEmitter.off('task-update', listener);
        controller.close();
      });
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  });
}</code></pre>

        <h2>Pattern Extension Auth (JWT)</h2>

        <pre><code class="language-javascript">// lib/api/withExtensionAuth.js
// Middleware d'authentification pour les routes /api/ext/*
import { verifyExtensionToken } from '@/lib/auth/extensionToken';

export async function withExtensionAuth(request) {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader?.startsWith('Bearer ')) {
    return ExtensionErrors.invalidCredentials();
  }

  const token = authHeader.slice(7);
  const payload = await verifyExtensionToken(token);

  if (!payload) {
    return ExtensionErrors.invalidCredentials();
  }

  return { userId: payload.userId };
}</code></pre>

        <h2>Conventions de Nommage</h2>

        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Convention</th>
              <th>Exemple</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Fichiers composants</td>
              <td>PascalCase</td>
              <td><code>CvEditor.jsx</code></td>
            </tr>
            <tr>
              <td>Fichiers lib</td>
              <td>camelCase</td>
              <td><code>featureUsage.js</code></td>
            </tr>
            <tr>
              <td>API Routes</td>
              <td>kebab-case</td>
              <td><code>/api/cv/match-score</code></td>
            </tr>
            <tr>
              <td>Modèles Prisma</td>
              <td>PascalCase</td>
              <td><code>CvFile</code>, <code>JobOffer</code></td>
            </tr>
            <tr>
              <td>Variables</td>
              <td>camelCase</td>
              <td><code>const userId</code></td>
            </tr>
            <tr>
              <td>Constantes</td>
              <td>SCREAMING_SNAKE</td>
              <td><code>MAX_RETRIES</code></td>
            </tr>
            <tr>
              <td>Feature names</td>
              <td>snake_case</td>
              <td><code>gpt_cv_generation</code></td>
            </tr>
            <tr>
              <td>Clés erreur i18n</td>
              <td>dot.notation</td>
              <td><code>errors.api.auth.emailRequired</code></td>
            </tr>
          </tbody>
        </table>

        <h2>Git Workflow</h2>

        <div class="card-grid">
          <div class="card">
            <h4>Branches</h4>
            <ul>
              <li><code>main</code> - Production</li>
              <li><code>release</code> - Stable</li>
              <li><code>dev</code> - Développement</li>
            </ul>
          </div>
          <div class="card">
            <h4>Préfixes branches</h4>
            <ul>
              <li><code>feat/</code> - Nouvelles fonctionnalités</li>
              <li><code>fix/</code> - Corrections</li>
              <li><code>chore/</code> - Maintenance</li>
              <li><code>hotfix/</code> - Urgences prod</li>
            </ul>
          </div>
          <div class="card">
            <h4>Conventional Commits</h4>
            <ul>
              <li><code>feat:</code> - Nouvelle feature (minor)</li>
              <li><code>fix:</code> - Bug fonctionnel (patch)</li>
              <li><code>chore:</code> - Tooling/CI (build)</li>
              <li><code>feat!:</code> - Breaking change (major)</li>
            </ul>
          </div>
          <div class="card">
            <h4>Versioning automatique</h4>
            <ul>
              <li>Format : <code>X.X.X.X</code> (4 parties)</li>
              <li>Bump automatique au merge sur <code>main</code></li>
              <li>Basé sur les préfixes de commits</li>
              <li>Script : <code>scripts/bump-version.sh</code></li>
            </ul>
          </div>
        </div>

        <h2>Déploiement CI/CD</h2>

        <div class="diagram">
          <div class="diagram-title">Pipeline de déploiement</div>
          <div class="mermaid">
flowchart LR
    PR["Demande de fusion<br/>vers main"] --> PreProd["Pre-prod<br/>dev.fitmycv.io:3001"]
    PreProd --> Test["Tests sur<br/>base dupliquée"]
    Merge["Fusion vers main"] --> Bump["Mise à jour<br/>version automatique"]
    Bump --> Deploy["Déploiement prod<br/>app.fitmycv.io:3000"]
    Deploy --> Sync["Synchronisation<br/>branches release + dev"]

    style PR fill:#0ea5e9,stroke:#0284c7,color:#fff
    style PreProd fill:#6366f1,stroke:#4f46e5,color:#fff
    style Test fill:#f59e0b,stroke:#d97706,color:#fff
    style Merge fill:#0ea5e9,stroke:#0284c7,color:#fff
    style Bump fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style Deploy fill:#22c55e,stroke:#16a34a,color:#fff
    style Sync fill:#64748b,stroke:#475569,color:#fff
          </div>
        </div>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
