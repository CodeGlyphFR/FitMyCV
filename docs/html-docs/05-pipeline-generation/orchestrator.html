<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orchestrateur - Pipeline G&eacute;n&eacute;ration | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <div id="sidebar-container"></div>
    <main class="main">
      <div id="header-container"></div>
      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Pipeline G&eacute;n&eacute;ration</a>
          <span>/</span>
          <span>Orchestrateur</span>
        </div>

        <h1>Orchestrateur</h1>
        <p class="lead">
          L'orchestrateur coordonne le cycle de vie complet d'une t&acirc;che de g&eacute;n&eacute;ration CV : cr&eacute;ation d'<code>AbortController</code>, r&eacute;cup&eacute;ration des donn&eacute;es depuis Prisma, ex&eacute;cution s&eacute;quentielle des phases (Extraction &rarr; Classification &rarr; Batches &rarr; Recomposition), gestion des cr&eacute;dits, retry avec backoff exponentiel et &eacute;v&eacute;nements SSE temps r&eacute;el.
        </p>

        <!-- ==================== ARCHITECTURE ==================== -->
        <h2>Architecture des Modules</h2>

        <div class="diagram">
          <div class="diagram-title">Modules de l'orchestrateur et leurs relations</div>
          <div class="mermaid">
flowchart TB
    subgraph OrchestratorMod["ORCHESTRATOR"]
        TaskRunner["taskRunner.js<br/>startSingleOfferGeneration<br/>startMultiOfferGeneration"]
        OfferProcessor["offerProcessor.js<br/>processOffer<br/>runBatchesPhase"]
        CreditManager["creditManager.js<br/>refundCreditForOffer"]
        ProgressEmitter["progressEmitter.js<br/>emitProgress"]
        RetryHandler["retryHandler.js<br/>withRetry"]
    end

    subgraph PhasesGroup["PHASES"]
        P0["extract.js"]
        P05["classify.js"]
        P1["batch-*.js x7"]
        P2["recompose.js"]
    end

    subgraph DBLayer["PRISMA"]
        TaskDB[(CvGenerationTask)]
        OfferDB[(CvGenerationOffer)]
        SubtaskDB[(CvGenerationSubtask)]
    end

    TaskRunner -->|"offerId"| OfferProcessor
    OfferProcessor -->|"chaque phase"| PhasesGroup
    OfferProcessor -->|"wrap fn"| RetryHandler
    TaskRunner -->|"refund on fail"| CreditManager
    OfferProcessor -->|"phase, step, status"| ProgressEmitter

    PhasesGroup --> SubtaskDB
    TaskRunner --> TaskDB
    OfferProcessor --> OfferDB

    style TaskRunner fill:#0ea5e9,stroke:#0284c7,color:#fff
    style OfferProcessor fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style CreditManager fill:#f59e0b,stroke:#d97706,color:#fff
    style ProgressEmitter fill:#6366f1,stroke:#4f46e5,color:#fff
    style RetryHandler fill:#64748b,stroke:#475569,color:#fff
    style P0 fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style P05 fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style P1 fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style P2 fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style TaskDB fill:#14b8a6,stroke:#0d9488,color:#fff
    style OfferDB fill:#14b8a6,stroke:#0d9488,color:#fff
    style SubtaskDB fill:#14b8a6,stroke:#0d9488,color:#fff
          </div>
        </div>

        <!-- ==================== TASKRUNNER ==================== -->
        <h2>taskRunner.js &mdash; Point d'Entr&eacute;e</h2>

        <p><strong>Fichier :</strong> <code>lib/features/cv-adaptation/orchestrator/taskRunner.js</code></p>

        <div class="data-flow">
          <div class="data-flow-header">startSingleOfferGeneration(taskId, offerId)</div>

          <div class="data-flow-section data-flow-input">
            <div class="data-flow-label">Lifecycle</div>
            <ol>
              <li>Cr&eacute;ation d'un <code>AbortController</code> &mdash; stock&eacute; dans <code>activeControllers</code> pour annulation externe</li>
              <li>R&eacute;cup&eacute;ration <code>CvGenerationTask</code> (+ <code>sourceCvFile</code>, <code>user</code>) et <code>CvGenerationOffer</code> depuis Prisma</li>
              <li>Mise &agrave; jour du statut : <code>offer.status = 'running'</code></li>
              <li>Emission SSE : <code>emitProgress(userId, context, 'extraction', 'start', 'running')</code></li>
              <li>Appel <code>executeExtraction()</code> &rarr; r&eacute;cup&eacute;ration <code>jobOffer</code></li>
              <li>Appel <code>processOffer()</code> &rarr; classification + batches + recomposition</li>
              <li>Mise &agrave; jour des statuts finaux : <code>offer.status = 'completed'</code>, <code>task.status = 'completed'</code></li>
              <li>Emission SSE : <code>emitProgress(..., 'complete', 'done', 'completed')</code></li>
            </ol>
          </div>

          <div class="data-flow-section data-flow-output">
            <div class="data-flow-label">Gestion des erreurs</div>
            <pre><code class="language-javascript">// En cas d'erreur :
// 1. offer.status = 'failed', task.status = 'failed'
// 2. Remboursement automatique via refundCreditForOffer()
// 3. Emission SSE erreur
// 4. Si error.name === 'AbortError' || signal.aborted → 'Task cancelled'

// AbortController nettoyé dans le bloc finally
activeControllers.delete(taskId);</code></pre>
          </div>
        </div>

        <div class="callout callout-info">
          <div class="callout-title">startMultiOfferGeneration(taskId)</div>
          <p>Variante pour traiter <strong>plusieurs offres</strong> s&eacute;quentiellement. Boucle sur chaque <code>CvGenerationOffer</code> du task et appelle <code>executeExtraction() + processOffer()</code> pour chacune. Le statut global passe en <code>'completed'</code> une fois toutes les offres trait&eacute;es.</p>
        </div>

        <!-- ==================== OFFERPROCESSOR ==================== -->
        <h2>offerProcessor.js &mdash; Coordination des Phases</h2>

        <p><strong>Fichier :</strong> <code>lib/features/cv-adaptation/orchestrator/offerProcessor.js</code></p>

        <h3>processOffer()</h3>

        <div class="data-flow">
          <div class="data-flow-header">processOffer(offer, sourceCv, jobOffer, userId, signal, context)</div>

          <div class="data-flow-section data-flow-prompt">
            <div class="data-flow-label">S&eacute;quence d'ex&eacute;cution</div>
            <ol>
              <li><strong>Classification</strong> &mdash; <code>executeClassification(offer.id, sourceCv, jobOffer, userId, signal)</code></li>
              <li><strong>Batches</strong> &mdash; <code>runBatchesPhase(offer, sourceCv, classificationResult, jobOffer, userId, signal, context)</code></li>
              <li><strong>Recomposition</strong> &mdash; <code>runRecompositionPhase(offer, sourceCv, batchResults, classificationResult, jobOffer, userId, signal, context)</code></li>
            </ol>
          </div>
        </div>

        <h3>runBatchesPhase()</h3>

        <div class="diagram">
          <div class="diagram-title">Ex&eacute;cution parall&egrave;le des 7 batches</div>
          <div class="mermaid">
flowchart TB
    ApplyClass["applyClassification<br/>Filtrage KEEP / MOVE_TO_PROJECTS"]

    subgraph ParallelBatches["Promise.all - 6 Batches"]
        Exp["executeBatchExperiences"]
        Proj["executeBatchProjects"]
        Extras["executeBatchExtras"]
        Edu["executeBatchEducation"]
        Lang["executeBatchLanguages"]
        SkillsBatch["executeBatchSkills"]
    end

    Summary["executeBatchSummary<br/>sequentiel apres Promise.all"]
    PostSkills["processSkillsResponse<br/>Post-traitement skills"]

    ApplyClass --> ParallelBatches
    ParallelBatches --> PostSkills
    ParallelBatches --> Summary

    style ApplyClass fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style Exp fill:#6366f1,stroke:#4f46e5,color:#fff
    style Proj fill:#6366f1,stroke:#4f46e5,color:#fff
    style Extras fill:#6366f1,stroke:#4f46e5,color:#fff
    style Edu fill:#6366f1,stroke:#4f46e5,color:#fff
    style Lang fill:#6366f1,stroke:#4f46e5,color:#fff
    style SkillsBatch fill:#6366f1,stroke:#4f46e5,color:#fff
    style Summary fill:#0ea5e9,stroke:#0284c7,color:#fff
    style PostSkills fill:#f59e0b,stroke:#d97706,color:#fff
          </div>
        </div>

        <div class="data-flow">
          <div class="data-flow-header">runBatchesPhase() &mdash; D&eacute;tail</div>

          <div class="data-flow-section data-flow-prompt">
            <div class="data-flow-label">Ordre d'ex&eacute;cution</div>
            <pre><code class="language-javascript">// 1. Appliquer la classification
const { experiences, projects } = applyClassification(sourceCv, classification);

// 2. 6 batches en parallèle (Promise.all)
const [expResults, projResults, extrasResults,
       eduResults, langResults, skillsResults] = await Promise.all([
  executeBatchExperiences(offerId, experiences, jobOffer, userId, signal),
  executeBatchProjects(offerId, projects, jobOffer, userId, signal),
  executeBatchExtras(offerId, sourceCv.extras, jobOffer, userId, signal),
  executeBatchEducation(offerId, sourceCv.education, jobOffer, userId, signal),
  executeBatchLanguages(offerId, sourceCv.languages, jobOffer, userId, signal),
  executeBatchSkills(offerId, sourceCv.skills, jobOffer, userId, signal)
]);

// 3. Post-traitement skills
const processedSkills = processSkillsResponse(skillsResults);

// 4. Summary séquentiel (nécessite résultats précédents → Cache B)
const summaryResult = await executeBatchSummary(
  offerId, sourceCv, expResults, projResults,
  processedSkills, jobOffer, userId, signal
);</code></pre>
          </div>
        </div>

        <!-- ==================== CREDITMANAGER ==================== -->
        <h2>creditManager.js &mdash; Gestion des Cr&eacute;dits</h2>

        <p><strong>Fichier :</strong> <code>lib/features/cv-adaptation/orchestrator/creditManager.js</code></p>

        <div class="data-flow">
          <div class="data-flow-header">refundCreditForOffer(taskId, offerId, userId, reason)</div>

          <div class="data-flow-section data-flow-prompt">
            <div class="data-flow-label">Processus de remboursement</div>
            <ol>
              <li>V&eacute;rifie si l'offre n'a pas d&eacute;j&agrave; &eacute;t&eacute; rembours&eacute;e (<code>offer.creditRefunded !== true</code>)</li>
              <li>R&eacute;cup&egrave;re le co&ucirc;t via <code>getCreditCostForFeature('gpt_cv_generation')</code></li>
              <li>Appelle <code>grantCredits(userId, cost, 'refund')</code></li>
              <li>Met &agrave; jour le flag <code>offer.creditRefunded = true</code></li>
              <li>Incr&eacute;mente <code>task.creditsRefunded</code></li>
            </ol>
          </div>

          <div class="data-flow-section data-flow-output">
            <div class="data-flow-label">S&eacute;curit&eacute;</div>
            <pre><code class="language-javascript">// Protection contre le double remboursement
const offer = await prisma.cvGenerationOffer.findUnique({ where: { id: offerId } });
if (offer.creditRefunded) {
  console.log('[creditManager] Already refunded, skipping');
  return;
}

// Remboursement
const cost = await getCreditCostForFeature('gpt_cv_generation');
await grantCredits(userId, cost, 'refund');

// Mise à jour DB
await prisma.cvGenerationOffer.update({
  where: { id: offerId },
  data: { creditRefunded: true }
});
await prisma.cvGenerationTask.update({
  where: { id: taskId },
  data: { creditsRefunded: { increment: 1 } }
});</code></pre>
          </div>
        </div>

        <!-- ==================== PROGRESSEMITTER ==================== -->
        <h2>progressEmitter.js &mdash; &Eacute;v&eacute;nements SSE</h2>

        <p><strong>Fichier :</strong> <code>lib/features/cv-adaptation/orchestrator/progressEmitter.js</code></p>

        <div class="data-flow">
          <div class="data-flow-header">emitProgress(userId, context, phase, step, status, extra)</div>

          <div class="data-flow-section data-flow-prompt">
            <div class="data-flow-label">Wrapper autour de dbEmitter</div>
            <pre><code class="language-javascript">// Signature
export function emitProgress(userId, context, phase, step, status, extra = {}) {
  dbEmitter.emitCvGenerationProgress(userId, {
    taskId: context.taskId,
    offerId: context.offerId,
    phase,    // 'extraction', 'classification', 'batches', 'recomposition', 'complete'
    step,     // 'start', 'progress', 'done', 'error'
    status,   // 'running', 'completed', 'failed'
    ...extra  // { batchName, itemIndex, totalItems, ... }
  });
}</code></pre>
          </div>

          <div class="data-flow-section data-flow-output">
            <div class="data-flow-label">&Eacute;v&eacute;nements &eacute;mis par phase</div>
            <table>
              <thead>
                <tr><th>Phase</th><th>Step</th><th>Extra</th></tr>
              </thead>
              <tbody>
                <tr><td><code>extraction</code></td><td>start / done</td><td><code>{ title }</code></td></tr>
                <tr><td><code>classification</code></td><td>start / done</td><td><code>{ stats }</code></td></tr>
                <tr><td><code>batches</code></td><td>start / progress / done</td><td><code>{ batchName, itemIndex, totalItems }</code></td></tr>
                <tr><td><code>recomposition</code></td><td>start / done</td><td>&mdash;</td></tr>
                <tr><td><code>complete</code></td><td>done</td><td><code>{ cvFileId }</code></td></tr>
              </tbody>
            </table>
          </div>
        </div>

        <!-- ==================== RETRYHANDLER ==================== -->
        <h2>retryHandler.js &mdash; Retry avec Backoff Exponentiel</h2>

        <p><strong>Fichier :</strong> <code>lib/features/cv-adaptation/orchestrator/retryHandler.js</code></p>

        <div class="card-grid">
          <div class="card">
            <h4>Constantes</h4>
            <table>
              <tr><td><code>MAX_RETRIES</code></td><td><strong>3</strong></td></tr>
              <tr><td><code>BACKOFF_BASE_MS</code></td><td><strong>1000</strong> ms</td></tr>
            </table>
            <p><strong>D&eacute;lais :</strong> 1s &rarr; 2s &rarr; 4s (exponentiel &times;2)</p>
          </div>
          <div class="card">
            <h4>Signature</h4>
            <pre><code class="language-javascript">withRetry(fn, maxRetries, context, onRetry)</code></pre>
            <ul>
              <li><code>fn</code> &mdash; Fonction async &agrave; ex&eacute;cuter</li>
              <li><code>maxRetries</code> &mdash; Par d&eacute;faut <code>MAX_RETRIES</code></li>
              <li><code>context</code> &mdash; Label pour les logs</li>
              <li><code>onRetry</code> &mdash; Callback <code>(attempt, delay, error)</code></li>
            </ul>
          </div>
        </div>

        <div class="data-flow">
          <div class="data-flow-header">Logique de retry</div>

          <div class="data-flow-section data-flow-prompt">
            <div class="data-flow-label">Algorithme</div>
            <pre><code class="language-javascript">export async function withRetry(fn, maxRetries = MAX_RETRIES, context = '', onRetry) {
  let lastError;
  for (let attempt = 0; attempt &lt;= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      // Erreurs non-retryables → throw immédiat
      if (error.name === 'AbortError' || error.message === 'Task cancelled') {
        throw error;
      }

      if (attempt &lt; maxRetries) {
        const delay = BACKOFF_BASE_MS * Math.pow(2, attempt); // 1s, 2s, 4s
        console.warn(`[withRetry] ${context} attempt ${attempt + 1} failed, retry in ${delay}ms`);
        onRetry?.(attempt + 1, delay, error);
        await new Promise(r =&gt; setTimeout(r, delay));
      }
    }
  }
  throw lastError;
}</code></pre>
          </div>
        </div>

        <div class="callout callout-warning">
          <div class="callout-title">Erreurs non-retryables</div>
          <p>Les erreurs <code>AbortError</code> et <code>'Task cancelled'</code> ne sont <strong>jamais</strong> retry&eacute;es &mdash; elles sont propag&eacute;es imm&eacute;diatement pour permettre l'annulation rapide de la t&acirc;che.</p>
        </div>

        <!-- ==================== CYCLE DE VIE ==================== -->
        <h2>Cycle de Vie d'une T&acirc;che</h2>

        <div class="diagram">
          <div class="diagram-title">&Eacute;tats d'une CvGenerationTask / CvGenerationOffer</div>
          <div class="mermaid">
graph TD
    START_NODE(("Start")) --> QUEUED["queued<br/>API Route cree la tache"]
    QUEUED --> RUNNING["running<br/>enqueueJob demarre"]
    RUNNING --> EXTRACTION["extraction<br/>Phase 0"]
    EXTRACTION --> CLASSIFICATION["classification<br/>Phase 0.5"]
    CLASSIFICATION --> BATCHES["batches<br/>Phase 1 - 6 paralleles + 1 sequentiel"]
    BATCHES --> RECOMPOSITION["recomposition<br/>Phase 2"]
    RECOMPOSITION --> COMPLETED["completed<br/>Succes"]
    RUNNING -->|"Erreur + refund"| FAILED["failed"]
    EXTRACTION -->|"Erreur extraction"| FAILED
    CLASSIFICATION -->|"Erreur classification"| FAILED
    BATCHES -->|"Erreur batch"| FAILED
    RECOMPOSITION -->|"Erreur recomposition"| FAILED
    RUNNING -->|"AbortController.abort"| CANCELLED["cancelled"]
    COMPLETED --> END_NODE(("End"))
    FAILED --> END_NODE
    CANCELLED --> END_NODE

    style START_NODE fill:#64748b,stroke:#475569,color:#fff
    style QUEUED fill:#0ea5e9,stroke:#0284c7,color:#fff
    style RUNNING fill:#6366f1,stroke:#4f46e5,color:#fff
    style EXTRACTION fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style CLASSIFICATION fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style BATCHES fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style RECOMPOSITION fill:#8b5cf6,stroke:#7c3aed,color:#fff
    style COMPLETED fill:#22c55e,stroke:#16a34a,color:#fff
    style FAILED fill:#ef4444,stroke:#dc2626,color:#fff
    style CANCELLED fill:#f59e0b,stroke:#d97706,color:#fff
    style END_NODE fill:#64748b,stroke:#475569,color:#fff
          </div>
        </div>

        <!-- ==================== TRACABILITE ==================== -->
        <h2>Tra&ccedil;abilit&eacute; &mdash; CvGenerationSubtask</h2>

        <p>Chaque appel IA est enregistr&eacute; dans <code>CvGenerationSubtask</code> pour le monitoring et le d&eacute;bogage :</p>

        <table>
          <thead>
            <tr>
              <th>Champ</th>
              <th>Type</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr><td><code>offerId</code></td><td>String</td><td>ID de l'offre parente</td></tr>
            <tr><td><code>type</code></td><td>String</td><td><code>'extraction'</code>, <code>'classification'</code>, <code>'batch_experience'</code>, <code>'batch_project'</code>, <code>'batch_extras'</code>, <code>'batch_education'</code>, <code>'batch_languages'</code>, <code>'batch_skills'</code>, <code>'batch_summary'</code></td></tr>
            <tr><td><code>itemIndex</code></td><td>Int?</td><td>Index de l'item (0, 1, 2... pour exp&eacute;riences)</td></tr>
            <tr><td><code>status</code></td><td>String</td><td><code>'pending'</code> &rarr; <code>'running'</code> &rarr; <code>'completed'</code> / <code>'failed'</code></td></tr>
            <tr><td><code>modelUsed</code></td><td>String</td><td>Mod&egrave;le OpenAI utilis&eacute;</td></tr>
            <tr><td><code>promptTokens</code></td><td>Int</td><td>Tokens prompt envoy&eacute;s</td></tr>
            <tr><td><code>cachedTokens</code></td><td>Int</td><td>Tokens depuis le cache OpenAI</td></tr>
            <tr><td><code>completionTokens</code></td><td>Int</td><td>Tokens g&eacute;n&eacute;r&eacute;s</td></tr>
            <tr><td><code>estimatedCost</code></td><td>Float</td><td>Co&ucirc;t estim&eacute; USD via <code>calculateCost()</code></td></tr>
            <tr><td><code>durationMs</code></td><td>Int</td><td>Dur&eacute;e d'ex&eacute;cution en ms</td></tr>
          </tbody>
        </table>

        <!-- ==================== FICHIERS ==================== -->
        <h2>Structure des Fichiers</h2>

        <pre><code class="language-bash">lib/features/cv-adaptation/orchestrator/
├── index.js              # Re-exports publics
├── taskRunner.js         # startSingleOfferGeneration, startMultiOfferGeneration
├── offerProcessor.js     # processOffer, runBatchesPhase, runRecompositionPhase
├── creditManager.js      # refundCreditForOffer
├── progressEmitter.js    # emitProgress → dbEmitter.emitCvGenerationProgress
└── retryHandler.js       # withRetry, MAX_RETRIES=3, BACKOFF_BASE_MS=1000</code></pre>

      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>