<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Orchestrateur - Pipeline Génération | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <!-- Sidebar injectée par layout.js -->
    <div id="sidebar-container"></div>

    <!-- Main Content -->
    <main class="main">
      <!-- Header injecté par layout.js -->
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <a href="./overview.html">Pipeline Génération</a>
          <span>/</span>
          <span>Orchestrateur</span>
        </div>

        <h1>Orchestrateur</h1>
        <p class="lead">
          L'orchestrateur coordonne l'exécution des différentes phases du pipeline de génération CV, gère les crédits, les erreurs et la progression.
        </p>

        <h2>Architecture</h2>

        <div class="diagram">
          <div class="diagram-title">Modules de l'orchestrateur</div>
          <div class="mermaid">
flowchart TB
    subgraph Orchestrator["ORCHESTRATOR"]
        TaskRunner["taskRunner.js<br/>Lifecycle management"]
        OfferProcessor["offerProcessor.js<br/>Coordination phases"]
        CreditManager["creditManager.js<br/>Débit/Refund"]
        ProgressEmitter["progressEmitter.js<br/>SSE events"]
        RetryHandler["retryHandler.js<br/>Error recovery"]
    end

    subgraph Phases["PHASES"]
        P0["Extract"]
        P05["Classify"]
        P1["Batches"]
        P2["Recompose"]
    end

    subgraph State["STATE"]
        Task[(CvGenerationTask)]
        Offer[(CvGenerationOffer)]
        Subtask[(CvGenerationSubtask)]
    end

    TaskRunner --> OfferProcessor
    OfferProcessor --> Phases
    TaskRunner --> CreditManager
    TaskRunner --> ProgressEmitter
    OfferProcessor --> RetryHandler

    Phases --> Subtask
    TaskRunner --> Task
    OfferProcessor --> Offer
          </div>
        </div>

        <h2>Modules</h2>

        <h3>taskRunner.js</h3>

        <p>Point d'entrée principal, gère le cycle de vie complet d'une tâche de génération.</p>

        <pre><code>// lib/features/cv-adaptation/orchestrator/taskRunner.js

export async function startSingleOfferGeneration(taskId, offerInput) {
  const task = await prisma.cvGenerationTask.findUnique({
    where: { id: taskId },
    include: { sourceCvFile: true }
  });

  try {
    // 1. Marquer la tâche comme running
    await updateTaskStatus(taskId, 'running');
    emitProgress(taskId, { phase: 'starting', progress: 0 });

    // 2. Débiter le crédit
    await debitCredit(task.userId, CREDIT_COST, 'gpt_cv_generation');

    // 3. Traiter l'offre
    const result = await processOffer(task, offerInput);

    // 4. Sauvegarder le CV généré
    const cvFile = await saveCvFile(task.userId, result.cv, result.jobOffer);

    // 5. Marquer comme completed
    await updateTaskStatus(taskId, 'completed', { cvFileId: cvFile.id });
    emitProgress(taskId, { phase: 'complete', progress: 100 });

    return cvFile;

  } catch (error) {
    // 6. Gérer l'échec
    await handleTaskFailure(taskId, task.userId, error);
    throw error;
  }
}

async function handleTaskFailure(taskId, userId, error) {
  // Rembourser le crédit
  await refundCredit(userId, CREDIT_COST, 'gpt_cv_generation', 'Task failed');

  // Mettre à jour le statut
  await updateTaskStatus(taskId, 'failed', {
    error: error.message
  });

  emitProgress(taskId, {
    phase: 'error',
    progress: 0,
    error: error.message
  });
}</code></pre>

        <h3>offerProcessor.js</h3>

        <p>Coordonne l'exécution séquentielle et parallèle des phases.</p>

        <pre><code>// lib/features/cv-adaptation/orchestrator/offerProcessor.js

export async function processOffer(task, offerInput) {
  const sourceCv = task.sourceCvFile.content;

  // Phase 0: Extraction de l'offre
  emitProgress(task.id, { phase: 'extraction', progress: 10 });
  const jobOffer = await extractJobOffer(offerInput);

  // Phase 0.5: Classification
  emitProgress(task.id, { phase: 'classification', progress: 20 });
  const classification = await classifyItems(sourceCv, jobOffer);

  // Construire le Cache A (pour phases parallèles)
  const cacheA = buildCacheA(jobOffer);

  // Phase 1: Batches en parallèle
  emitProgress(task.id, { phase: 'adaptation', progress: 30 });
  const [
    adaptedExperiences,
    adaptedProjects,
    adaptedExtras
  ] = await Promise.all([
    batchExperiences(sourceCv, classification, cacheA),
    batchProjects(sourceCv, classification, cacheA),
    batchExtras(sourceCv, cacheA)
  ]);

  // Construire le Cache B (avec résultats)
  const cacheB = buildCacheB(cacheA, adaptedExperiences, adaptedProjects);

  // Phase 1 suite: Skills et Summary (dépendent de B)
  emitProgress(task.id, { phase: 'skills', progress: 60 });
  const [adaptedSkills, summary] = await Promise.all([
    batchSkills(sourceCv, jobOffer, cacheB),
    batchSummary(sourceCv, jobOffer, cacheB)
  ]);

  // Phase 2: Recomposition
  emitProgress(task.id, { phase: 'recomposition', progress: 80 });
  const finalCv = await recompose({
    header: sourceCv.header,
    experiences: adaptedExperiences,
    projects: adaptedProjects,
    skills: adaptedSkills,
    summary,
    extras: adaptedExtras,
    education: sourceCv.sections.education
  });

  emitProgress(task.id, { phase: 'finalizing', progress: 95 });

  return { cv: finalCv, jobOffer };
}</code></pre>

        <h3>creditManager.js</h3>

        <pre><code>// lib/features/cv-adaptation/orchestrator/creditManager.js

import { debitCredit as debit, refundCredit as refund } from '@/lib/subscription/credits';

const CREDIT_COST = 2; // Configurable via Setting

export async function debitGenerationCredit(userId) {
  return debit(userId, CREDIT_COST, 'gpt_cv_generation');
}

export async function refundGenerationCredit(userId, reason) {
  return refund(userId, CREDIT_COST, 'gpt_cv_generation', reason);
}</code></pre>

        <h3>progressEmitter.js</h3>

        <pre><code>// lib/features/cv-adaptation/orchestrator/progressEmitter.js

const listeners = new Map();

export function emitProgress(taskId, data) {
  const taskListeners = listeners.get(taskId) || [];
  taskListeners.forEach(callback => callback(data));

  // Aussi mettre à jour en DB pour persistance
  prisma.cvGenerationTask.update({
    where: { id: taskId },
    data: {
      progress: data.progress,
      currentPhase: data.phase
    }
  }).catch(console.error);
}

export function onProgress(taskId, callback) {
  if (!listeners.has(taskId)) {
    listeners.set(taskId, []);
  }
  listeners.get(taskId).push(callback);

  // Retourner fonction de cleanup
  return () => {
    const taskListeners = listeners.get(taskId);
    const index = taskListeners.indexOf(callback);
    if (index > -1) taskListeners.splice(index, 1);
  };
}</code></pre>

        <h3>retryHandler.js</h3>

        <pre><code>// lib/features/cv-adaptation/orchestrator/retryHandler.js

const MAX_RETRIES = 3;
const BASE_DELAY = 1000;

export async function withRetry(fn, options = {}) {
  const { maxRetries = MAX_RETRIES, onRetry } = options;
  let lastError;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      // Erreurs non-retryables
      if (isNonRetryable(error)) {
        throw error;
      }

      if (attempt < maxRetries) {
        const delay = BASE_DELAY * Math.pow(2, attempt);
        onRetry?.(attempt + 1, delay, error);
        await sleep(delay);
      }
    }
  }

  throw lastError;
}

function isNonRetryable(error) {
  // Erreurs de validation, auth, etc.
  return error.code === 'VALIDATION_ERROR'
    || error.code === 'AUTH_ERROR'
    || error.status === 400
    || error.status === 401;
}</code></pre>

        <h2>Cycle de Vie</h2>

        <div class="diagram">
          <div class="diagram-title">États d'une tâche de génération</div>
          <div class="mermaid">
stateDiagram-v2
    [*] --> pending: Création tâche
    pending --> running: Job démarré
    running --> extraction: Phase 0
    extraction --> classification: Phase 0.5
    classification --> adaptation: Phase 1 (parallèle)
    adaptation --> recomposition: Phase 2
    recomposition --> completed: Succès
    running --> failed: Erreur
    extraction --> failed: Erreur extraction
    classification --> failed: Erreur classification
    adaptation --> failed: Erreur batch
    completed --> [*]
    failed --> [*]
          </div>
        </div>

        <h2>Traçabilité</h2>

        <p>Chaque appel IA est enregistré dans <code>CvGenerationSubtask</code> :</p>

        <pre><code>await prisma.cvGenerationSubtask.create({
  data: {
    offerId: offer.id,
    type: 'batch_experience',
    phase: 1,
    input: JSON.stringify(inputData),
    output: JSON.stringify(result),
    promptTokens: usage.prompt_tokens,
    completionTokens: usage.completion_tokens,
    cachedTokens: usage.cached_tokens,
    totalTokens: usage.total_tokens,
    estimatedCost: calculateCost(usage),
    duration: endTime - startTime,
    model: 'gpt-4o'
  }
});</code></pre>

        <h2>Fichiers</h2>

        <pre><code>lib/features/cv-adaptation/orchestrator/
├── index.js              # Exports publics
├── taskRunner.js         # Lifecycle management
├── offerProcessor.js     # Coordination phases
├── creditManager.js      # Gestion crédits
├── progressEmitter.js    # SSE events
└── retryHandler.js       # Error recovery</code></pre>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
