<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Background Jobs - Vue d'ensemble | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <div id="sidebar-container"></div>
    <main class="main">
      <div id="header-container"></div>
      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <span>Background Jobs</span>
        </div>

        <h1>Background Jobs</h1>
        <p class="lead">
          Système de tâches asynchrones in-process basé sur une queue mémoire, un framework <code>createJobRunner</code>, un registre d'annulation via <code>AbortController</code>, et une synchronisation temps réel par SSE.
        </p>

        <!-- Architecture globale -->
        <h2>Architecture</h2>

        <div class="diagram">
          <div class="diagram-title">Flux de traitement des background jobs</div>
          <div class="mermaid">
flowchart TB
    subgraph API["API LAYER (app/api/background-tasks/*)"]
        Request["POST requête utilisateur"]
        Auth["Auth + canStartTaskType()"]
        Feature["incrementFeatureCounter()"]
        CreateTask["Créer BackgroundTask en DB (status: queued)"]
        Schedule["schedule(jobInput)"]
    end

    subgraph Queue["JOB QUEUE (lib/background-jobs/jobQueue.js)"]
        Enqueue["enqueueJob(jobRunner)"]
        Check["activeJobs < MAX_CONCURRENT_JOBS ? (3)"]
        Execute["Exécuter le job"]
        Release["activeJobs-- + setImmediate(processQueue)"]
    end

    subgraph Runner["JOB RUNNER (lib/background-jobs/jobRunner.js)"]
        PreCheck["Vérifier status != cancelled"]
        Abort["Setup AbortController + registerAbortController()"]
        BeforeRun["beforeRun() hook"]
        Service["getService() → prepareInput() → service()"]
        HandleResult["handleResult() → afterRun()"]
        Track["trackSuccess() / trackError()"]
        Cleanup["cleanup() + clearRegisteredProcess()"]
    end

    subgraph Events["TEMPS RÉEL"]
        UpdateTask["updateBackgroundTask() → prismaWithEvents"]
        Emitter["dbEmitter.emit('task:updated')"]
        SSE["SSE /api/events/stream"]
        Client["Client React"]
    end

    Request --> Auth --> Feature --> CreateTask --> Schedule
    Schedule --> Enqueue --> Check
    Check -->|Oui| Execute
    Check -->|Non| Queue

    Execute --> PreCheck --> Abort --> BeforeRun --> Service --> HandleResult --> Track --> Cleanup
    Cleanup --> Release

    HandleResult --> UpdateTask
    UpdateTask --> Emitter --> SSE --> Client

    Service -->|Erreur ou annulation| Track
          </div>
        </div>

        <!-- Composants principaux -->
        <h2>Composants principaux</h2>

        <div class="card-grid">
          <div class="card">
            <h3>jobQueue.js</h3>
            <p>Queue FIFO en mémoire avec limite de <strong>3 jobs concurrents</strong> (constante <code>MAX_CONCURRENT_JOBS</code>). Chaque job est une fonction async qui est dépilée par <code>processQueue()</code> via <code>setImmediate</code>.</p>
          </div>
          <div class="card">
            <h3>jobRunner.js</h3>
            <p>Framework générique <code>createJobRunner(config)</code> qui retourne <code>{ schedule, run }</code>. Gère le cycle complet : vérification pré-run, AbortController, hooks before/after, tracking télémétrie, cleanup, et remboursement crédits en cas d'erreur.</p>
          </div>
          <div class="card">
            <h3>processRegistry.js</h3>
            <p>Registre global (<code>Symbol.for</code>) de tous les AbortControllers actifs. Permet l'annulation à la demande via <code>killRegisteredProcess(taskId)</code> — supporte les tâches JS (AbortController) et les anciens processus externes (SIGTERM/SIGKILL).</p>
          </div>
          <div class="card">
            <h3>taskTypes.js</h3>
            <p>Constantes centralisées : <code>TASK_TYPES</code> (7 types), <code>AI_GENERATION_TYPES</code> (sous-ensemble), et helpers <code>isAiGenerationTask()</code>, <code>isMatchScoreTask()</code>, <code>isImprovementTask()</code>.</p>
          </div>
        </div>

        <!-- Cycle de vie d'un job -->
        <h2>Cycle de vie d'un job</h2>

        <div class="diagram">
          <div class="diagram-title">États d'une BackgroundTask</div>
          <div class="mermaid">
stateDiagram-v2
    [*] --> queued : Création
    queued --> running : Job dépilé de la queue
    running --> completed : handleResult() réussi
    running --> failed : Erreur ou quota dépassé
    running --> cancelled : AbortController.abort()
    queued --> cancelled : Annulation avant exécution
    failed --> [*]
    completed --> [*]
    cancelled --> [*]
          </div>
        </div>

        <div class="callout callout-info">
          <strong>Remboursement automatique</strong> — En cas d'erreur (<code>failed</code>) ou d'annulation (<code>cancelled</code>), la fonction <code>refundFeatureUsage(taskId)</code> rembourse automatiquement les crédits débités au lancement de la tâche.
        </div>

        <!-- Contrôle de concurrence -->
        <h2>Contrôle de concurrence par utilisateur</h2>

        <p>Le module <code>jobQueue.js</code> gère la concurrence à deux niveaux :</p>

        <table>
          <thead>
            <tr>
              <th>Constante</th>
              <th>Valeur</th>
              <th>Règle</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>MAX_CONCURRENT_JOBS</code></td>
              <td>3</td>
              <td>Maximum de jobs exécutés simultanément dans le processus Node.js</td>
            </tr>
            <tr>
              <td><code>MAX_CONCURRENT_TASK_TYPES</code></td>
              <td>3</td>
              <td>Maximum de types de tâches différents en parallèle par utilisateur</td>
            </tr>
            <tr>
              <td><code>MAX_CV_GENERATION_PER_USER</code></td>
              <td>3</td>
              <td>Exception : <code>cv_generation</code> peut avoir jusqu'à 3 instances simultanées par utilisateur</td>
            </tr>
          </tbody>
        </table>

        <p>La fonction <code>canStartTaskType(userId, taskType)</code> vérifie ces règles et retourne <code>{ allowed, reason, message }</code>. Le tracking utilise une <code>Map&lt;userId, Map&lt;taskType, count&gt;&gt;</code> en mémoire.</p>

        <!-- SSE temps réel -->
        <h2>Synchronisation temps réel (SSE)</h2>

        <p>Le endpoint <code>/api/events/stream</code> maintient une connexion SSE permanente par utilisateur connecté :</p>

        <pre><code class="language-javascript">// Événements SSE émis pour les background tasks
dbEmitter.on('task:updated', ({ taskId, userId, data }) => {
  sendEvent('task:updated', { taskId, data, timestamp: Date.now() });
});

// Keep-alive toutes les 30 secondes
setInterval(() => {
  controller.enqueue(encoder.encode(': keep-alive\n\n'));
}, 30000);</code></pre>

        <p>15 types d'événements sont émis au total : <code>task:updated</code>, <code>cv:updated</code>, <code>db:change</code>, <code>cv_generation:*</code> (4 events), <code>cv_improvement:*</code> (3 events), <code>credits:updated</code>, <code>settings:updated</code>, <code>onboarding:updated</code>, <code>onboarding:reset</code>, <code>email:verified</code>.</p>

        <!-- Nettoyage au démarrage -->
        <h2>Nettoyage au démarrage</h2>

        <p>Le module <code>cleanupOrphanedTasks.js</code> s'exécute au boot du serveur et :</p>
        <ul>
          <li>Passe toutes les <code>BackgroundTask</code> en status <code>running</code> ou <code>queued</code> à <code>failed</code> avec le message <em>"Tâche interrompue par le redémarrage du serveur"</em></li>
          <li>Réinitialise les <code>CvFile.matchScoreStatus</code> en <code>inprogress</code> → <code>idle</code></li>
          <li>Réinitialise les <code>CvFile.optimiseStatus</code> en <code>inprogress</code> → <code>idle</code></li>
        </ul>

        <!-- Rétention des données (RGPD) -->
        <h2>Jobs de rétention des données (RGPD)</h2>

        <p>Le module <code>dataRetention.js</code> exécute 4 tâches de conformité RGPD :</p>

        <table>
          <thead>
            <tr>
              <th>Fonction</th>
              <th>Action</th>
              <th>Seuil</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>cleanupEmailLogs()</code></td>
              <td>Suppression des logs d'emails</td>
              <td>> 12 mois</td>
            </tr>
            <tr>
              <td><code>cleanupConsentLogs()</code></td>
              <td>Suppression des logs de consentement cookies</td>
              <td>> 6 mois</td>
            </tr>
            <tr>
              <td><code>notifyInactiveAccounts()</code></td>
              <td>Email d'avertissement aux comptes inactifs</td>
              <td>2 ans et 11 mois (fenêtre de 1 mois)</td>
            </tr>
            <tr>
              <td><code>cleanupInactiveAccounts()</code></td>
              <td>Suppression complète des comptes inactifs (via <code>deleteUserCompletely</code>)</td>
              <td>> 3 ans</td>
            </tr>
          </tbody>
        </table>

        <div class="callout callout-warning">
          <strong>Protection admin</strong> — Les comptes avec <code>role: 'ADMIN'</code> ne sont jamais supprimés par les jobs de rétention.
        </div>

        <!-- API Sync -->
        <h2>API de synchronisation</h2>

        <p>Le endpoint <code>/api/background-tasks/sync</code> gère la persistance et synchronisation des tâches :</p>

        <table>
          <thead>
            <tr>
              <th>Méthode</th>
              <th>Action</th>
              <th>Détails</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>GET</code></td>
              <td>Récupérer les tâches</td>
              <td>Sync incrémentale (param <code>since</code>) ou complète. Max 150 tâches retournées.</td>
            </tr>
            <tr>
              <td><code>POST</code></td>
              <td>Synchroniser les tâches</td>
              <td>Upsert des tâches client. Limite de 100 tâches persistées par utilisateur (les plus anciennes sont supprimées).</td>
            </tr>
            <tr>
              <td><code>DELETE ?action=cancel</code></td>
              <td>Annuler une tâche</td>
              <td>Met en <code>cancelled</code>, tue le processus via <code>killRegisteredProcess</code>, rembourse les crédits, réinitialise les statuts CV.</td>
            </tr>
            <tr>
              <td><code>DELETE ?action=deleteCompleted</code></td>
              <td>Supprimer des tâches terminées</td>
              <td>Suppression par lot d'IDs.</td>
            </tr>
          </tbody>
        </table>

        <!-- Fichiers clés -->
        <h2>Fichiers clés</h2>

        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>Rôle</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>lib/background-jobs/jobQueue.js</code></td>
              <td>Queue FIFO + contrôle concurrence (3 max) + gestion types par utilisateur</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/jobRunner.js</code></td>
              <td>Framework générique <code>createJobRunner(config)</code></td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/processRegistry.js</code></td>
              <td>Registre global des AbortControllers actifs</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/taskTypes.js</code></td>
              <td>Constantes des 7 types de tâches + helpers</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/taskFeatureMapping.js</code></td>
              <td>Mapping types → featureNames télémétrie + durées estimées</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/cleanupOrphanedTasks.js</code></td>
              <td>Nettoyage des tâches orphelines au boot</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/dataRetention.js</code></td>
              <td>Jobs RGPD (cleanup logs, comptes inactifs)</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/sortTasks.js</code></td>
              <td>Tri des tâches pour affichage (running en premier, puis par date)</td>
            </tr>
            <tr>
              <td><code>app/api/background-tasks/sync/route.js</code></td>
              <td>API CRUD de synchronisation des tâches</td>
            </tr>
            <tr>
              <td><code>app/api/events/stream/route.js</code></td>
              <td>Endpoint SSE temps réel (15 types d'événements)</td>
            </tr>
          </tbody>
        </table>

        <h2>Prochaines sections</h2>
        <ul>
          <li><a href="./task-types.html">Types de tâches</a> — Les 7 types de background tasks et leur configuration</li>
          <li><a href="./concurrency.html">Concurrence</a> — Règles de concurrence par utilisateur et gestion des limites</li>
        </ul>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>
  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
