<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Background Jobs | FitMyCV.io</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../assets/css/style.css?v=1.0.4">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({ startOnLoad: false });</script>
</head>
<body>
  <div class="layout">
    <!-- Sidebar injectée par layout.js -->
    <div id="sidebar-container"></div>

    <!-- Main Content -->
    <main class="main">
      <!-- Header injecté par layout.js -->
      <div id="header-container"></div>

      <div class="content">
        <div class="breadcrumb">
          <a href="../index.html">Docs</a>
          <span>/</span>
          <span>Background Jobs</span>
        </div>

        <h1>Background Jobs</h1>
        <p class="lead">
          Le système de background jobs permet d'exécuter des tâches longues de manière asynchrone avec suivi de progression et gestion des erreurs.
        </p>

        <h2>Architecture</h2>

        <div class="diagram">
          <div class="diagram-title">Flux de traitement des jobs</div>
          <div class="mermaid">
flowchart TB
    subgraph API["API LAYER"]
        Request["Request utilisateur"]
        Validate["Validation & Auth"]
        Create["Créer tâche en DB"]
    end

    subgraph Queue["JOB QUEUE"]
        Enqueue["enqueueJob()"]
        Concurrency["Contrôle concurrence<br/>(max 3)"]
        Exécute["Exécution job"]
    end

    subgraph Progress["PROGRESSION"]
        DB[(BackgroundTask)]
        SSE["SSE Events"]
        Client["Client browser"]
    end

    subgraph Handler["ERROR HANDLING"]
        Retry["Retry logic"]
        Backoff["Exponential backoff"]
        Refund["Refund crédits"]
    end

    Request --> Validate --> Create
    Create --> Enqueue
    Enqueue --> Concurrency
    Concurrency --> Exécute

    Exécute --> DB
    DB --> SSE
    SSE --> Client

    Exécute -->|Échec| Handler
    Handler --> Retry
    Retry -->|Max retries| Refund
          </div>
        </div>

        <h2>Types de Tâches</h2>

        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Description</th>
              <th>Durée moyenne</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>cv_generation</code></td>
              <td>Pipeline génération CV</td>
              <td>30-60 secondes</td>
            </tr>
            <tr>
              <td><code>cv_optimization</code></td>
              <td>Pipeline optimisation CV</td>
              <td>20-40 secondes</td>
            </tr>
            <tr>
              <td><code>pdf_import</code></td>
              <td>Import et extraction PDF</td>
              <td>10-20 secondes</td>
            </tr>
            <tr>
              <td><code>pdf_export</code></td>
              <td>Export CV vers PDF</td>
              <td>5-10 secondes</td>
            </tr>
            <tr>
              <td><code>translation</code></td>
              <td>Traduction CV</td>
              <td>15-30 secondes</td>
            </tr>
          </tbody>
        </table>

        <h2>Modèle de Données</h2>

        <pre><code>// prisma/schema.prisma

model BackgroundTask {
  id          Int       @id @default(autoincrement())
  userId      String
  type        String    // cv_generation, pdf_import, etc.
  status      String    @default("pending") // pending, running, completed, failed
  payload     Json?     // Données d'entrée
  result      Json?     // Résultat ou erreur
  progress    Int       @default(0) // 0-100
  message     String?   // Message de progression
  retryCount  Int       @default(0)
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user        User      @relation(fields: [userId], references: [id])

  @@index([userId, status])
  @@index([type, status])
}</code></pre>

        <h2>Job Queue</h2>

        <h3>Enqueue un Job</h3>

        <pre><code>// lib/background-jobs/jobQueue.js

const MAX_CONCURRENT = 3;
let currentJobs = 0;
const queue = [];

export function enqueueJob(jobFn) {
  return new Promise((resolve, reject) => {
    queue.push({ jobFn, resolve, reject });
    processQueue();
  });
}

async function processQueue() {
  if (currentJobs >= MAX_CONCURRENT || queue.length === 0) {
    return;
  }

  currentJobs++;
  const { jobFn, resolve, reject } = queue.shift();

  try {
    const result = await jobFn();
    resolve(result);
  } catch (error) {
    reject(error);
  } finally {
    currentJobs--;
    processQueue(); // Traiter le suivant
  }
}</code></pre>

        <h3>Utilisation</h3>

        <pre><code>// app/api/cv/generate/route.js
import { enqueueJob } from '@/lib/background-jobs/jobQueue';
import { startSingleOfferGeneration } from '@/lib/cv-generation';

export async function POST(request) {
  const session = await auth();
  const { sourceCvId, jobOfferUrl } = await request.json();

  // 1. Créer la tâche en DB
  const task = await prisma.cvGenerationTask.create({
    data: {
      userId: session.user.id,
      sourceCvFileId: sourceCvId,
      mode: 'adapt',
      status: 'pending',
      totalOffers: 1
    }
  });

  // 2. Enqueue le job (non-bloquant)
  enqueueJob(async () => {
    await startSingleOfferGeneration(task.id, jobOfferUrl);
  });

  // 3. Retourner immédiatement
  return Response.json({
    taskId: task.id,
    status: 'pending',
    message: 'Generation started'
  });
}</code></pre>

        <h2>Progression SSE</h2>

        <div class="diagram">
          <div class="diagram-title">Flux Server-Sent Events</div>
          <div class="mermaid">
sequenceDiagram
    participant C as Client
    participant API as API /progress
    participant Job as Background Job
    participant DB as Database

    C->>API: GET /api/task/[id]/progress
    API-->>C: SSE Connection opened

    loop Pendant l'exécution
        Job->>DB: Update progress
        DB-->>API: Change detected
        API-->>C: event: progress
    end

    Job->>DB: status = completed
    DB-->>API: Final status
    API-->>C: event: complete
    API-->>C: Connection closed
          </div>
        </div>

        <h3>Endpoint SSE</h3>

        <pre><code>// app/api/task/[id]/progress/route.js

export async function GET(request, { params }) {
  const taskId = params.id;

  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    async start(controller) {
      // Fonction pour envoyer un event
      const sendEvent = (data) => {
        controller.enqueue(
          encoder.encode(`data: ${JSON.stringify(data)}\n\n`)
        );
      };

      // Poll la DB pour les mises à jour
      const checkProgress = async () => {
        const task = await prisma.backgroundTask.findUnique({
          where: { id: parseInt(taskId) }
        });

        if (!task) {
          sendEvent({ type: 'error', message: 'Task not found' });
          controller.close();
          return;
        }

        sendEvent({
          type: task.status === 'completed' ? 'complete' : 'progress',
          progress: task.progress,
          message: task.message,
          status: task.status,
          result: task.result
        });

        if (task.status === 'completed' || task.status === 'failed') {
          controller.close();
        } else {
          setTimeout(checkProgress, 1000); // Poll toutes les secondes
        }
      };

      checkProgress();
    }
  });

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  });
}</code></pre>

        <h3>Client React</h3>

        <pre><code>// hooks/useTaskProgress.js
import { useState, useEffect } from 'react';

export function useTaskProgress(taskId) {
  const [progress, setProgress] = useState(0);
  const [message, setMessage] = useState('');
  const [status, setStatus] = useState('pending');
  const [result, setResult] = useState(null);

  useEffect(() => {
    if (!taskId) return;

    const eventSource = new EventSource(`/api/task/${taskId}/progress`);

    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      setProgress(data.progress);
      setMessage(data.message);
      setStatus(data.status);

      if (data.type === 'complete' || data.type === 'error') {
        setResult(data.result);
        eventSource.close();
      }
    };

    eventSource.onerror = () => {
      eventSource.close();
      setStatus('error');
    };

    return () => eventSource.close();
  }, [taskId]);

  return { progress, message, status, result };
}</code></pre>

        <h2>Retry & Error Handling</h2>

        <pre><code>// lib/background-jobs/retryHandler.js

const MAX_RETRIES = 3;
const BASE_DELAY = 1000; // 1 seconde

export async function withRetry(taskId, jobFn) {
  let lastError;

  for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
    try {
      // Mettre à jour le retry count
      await prisma.backgroundTask.update({
        where: { id: taskId },
        data: { retryCount: attempt }
      });

      return await jobFn();

    } catch (error) {
      lastError = error;

      if (attempt < MAX_RETRIES) {
        // Exponential backoff: 1s, 2s, 4s
        const delay = BASE_DELAY * Math.pow(2, attempt);

        await prisma.backgroundTask.update({
          where: { id: taskId },
          data: {
            message: `Retry ${attempt + 1}/${MAX_RETRIES} in ${delay/1000}s...`
          }
        });

        await sleep(delay);
      }
    }
  }

  // Échec définitif
  await prisma.backgroundTask.update({
    where: { id: taskId },
    data: {
      status: 'failed',
      result: { error: lastError.message },
      completedAt: new Date()
    }
  });

  throw lastError;
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}</code></pre>

        <h2>Monitoring</h2>

        <table>
          <thead>
            <tr>
              <th>Métrique</th>
              <th>Description</th>
              <th>Alerte si</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Jobs en attente</td>
              <td>Tâches status=pending</td>
              <td>> 10 depuis > 5 min</td>
            </tr>
            <tr>
              <td>Jobs échoués</td>
              <td>Tâches status=failed (24h)</td>
              <td>> 5% du total</td>
            </tr>
            <tr>
              <td>Durée moyenne</td>
              <td>Temps d'exécution par type</td>
              <td>> 2x la normale</td>
            </tr>
            <tr>
              <td>Retries</td>
              <td>Jobs avec retryCount > 0</td>
              <td>> 20% des jobs</td>
            </tr>
          </tbody>
        </table>

        <h2>Fichiers Clés</h2>

        <table>
          <thead>
            <tr>
              <th>Fichier</th>
              <th>Rôle</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>lib/background-jobs/jobQueue.js</code></td>
              <td>Queue avec contrôle concurrence</td>
            </tr>
            <tr>
              <td><code>lib/background-jobs/retryHandler.js</code></td>
              <td>Retry avec exponential backoff</td>
            </tr>
            <tr>
              <td><code>lib/sse/sseHelpers.js</code></td>
              <td>Helpers Server-Sent Events</td>
            </tr>
            <tr>
              <td><code>app/api/task/[id]/progress/route.js</code></td>
              <td>Endpoint SSE progression</td>
            </tr>
          </tbody>
        </table>
      </div>
    </main>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-jsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-tsx.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js"></script>

  <script src="../assets/js/layout.js?v=1.0.4"></script>
  <script src="../assets/js/main.js?v=1.0.4"></script>
</body>
</html>
