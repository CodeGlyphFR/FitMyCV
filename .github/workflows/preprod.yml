name: ðŸ§ª Pre-prod (PR Lifecycle)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, closed]

jobs:
  deploy-preview:
    if: github.event.action != 'closed'
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract Public Config from local .env
        id: vars
        run: |
          # On extrait les 3 clÃ©s critiques pour le build frontend
          RECAPTCHA=$(grep '^NEXT_PUBLIC_RECAPTCHA_SITE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          STRIPE_PK=$(grep '^NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          
          # On force l'URL de staging pour que Stripe et l'Auth ne pointent pas vers la prod
          echo "RECAPTCHA_KEY=$RECAPTCHA" >> $GITHUB_ENV
          echo "STRIPE_PK=$STRIPE_PK" >> $GITHUB_ENV
          echo "APP_URL=https://dev.fitmycv.io" >> $GITHUB_ENV

      - name: Clone DB (Prod -> Release)
        run: |
          # Clone standard
          pg_dump fitmycv_prod > /tmp/prod_sync.sql
          psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = 'fitmycv_release' AND pid <> pg_backend_pid();" postgres || true
          dropdb --if-exists fitmycv_release
          createdb fitmycv_release
          psql fitmycv_release < /tmp/prod_sync.sql
          
          # Nettoyage des clients de prod (impÃ©ratif)
          psql fitmycv_release -c "UPDATE \"User\" SET \"stripeCustomerId\" = NULL;"

      - name: Auto-Sync Stripe Products
        run: |
          echo "--- DEBUG : OÃ™ SUIS-JE ? ---"
          pwd
          echo "--- DEBUG : LISTE DES FICHIERS ---"
          ls -R | grep -i sync-stripe.js
          
          # Extraction sÃ©curisÃ©e des credentials
          DB_PASS=$(grep '^DATABASE_URL=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d ':' -f3 | cut -d '@' -f1)
          export DATABASE_URL="postgresql://fitmycv:$DB_PASS@localhost:5432/fitmycv_release"
          export STRIPE_SECRET_KEY=$(grep '^STRIPE_SECRET_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2- | tr -d '"')

          # On cherche le fichier et on l'exÃ©cute peu importe oÃ¹ il est
          SCRIPT_PATH=$(find . -name "sync-stripe.js" | head -n 1)
          
          if [ -z "$SCRIPT_PATH" ]; then
            echo "ERREUR : sync-stripe.js est introuvable dans tout le rÃ©pertoire !"
            exit 1
          fi
          
          echo "ExÃ©cution de : $SCRIPT_PATH"
          node "$SCRIPT_PATH"

      - name: Docker Build
        run: |
          # On injecte les variables publiques pour que Next.js les "cuise" dans le JS
          docker build \
            --build-arg NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ env.RECAPTCHA_KEY }}" \
            --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ env.STRIPE_PK }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ env.APP_URL }}" \
            --build-arg NEXT_PUBLIC_APP_URL="${{ env.APP_URL }}" \
            -t fitmycv:preview .

      - name: Deploy via Docker Compose (Staging)
        run: |
          cd /home/erickdesmet/STAGING_SAAS/FitMyCV/app
          
          # 1. On tente un arrÃªt propre
          docker compose -f docker-compose.staging.yml down || true
          
          # 2. SOLUTION AU BUG : On force la suppression du container par son nom.
          # Cela dÃ©bloque l'Ã©tat "removal in progress" si Docker est perdu.
          docker rm -f fitmycv-preview || true
          
          # 3. On relance avec la nouvelle image buildÃ©e.
          # --force-recreate garantit qu'on ne rÃ©utilise pas un vieux container.
          docker compose -f docker-compose.staging.yml up -d --force-recreate
          
          # 4. On attend que l'app soit prÃªte pour les migrations
          sleep 10

      - name: Post-deploy (Migrations)
        run: |
          docker exec fitmycv-preview npm run db:migrate-deploy
          docker exec fitmycv-preview npm run db:migrate-data
