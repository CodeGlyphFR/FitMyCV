name: ðŸ§ª Pre-prod (PR Lifecycle)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, closed]

jobs:
  deploy-preview:
    if: github.event.action != 'closed'
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract Public Config from local .env
        id: vars
        run: |
          # On extrait les 3 clÃ©s critiques pour le build frontend
          RECAPTCHA=$(grep '^NEXT_PUBLIC_RECAPTCHA_SITE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          STRIPE_PK=$(grep '^NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          
          # On force l'URL de staging pour que Stripe et l'Auth ne pointent pas vers la prod
          echo "RECAPTCHA_KEY=$RECAPTCHA" >> $GITHUB_ENV
          echo "STRIPE_PK=$STRIPE_PK" >> $GITHUB_ENV
          echo "APP_URL=https://dev.fitmycv.io" >> $GITHUB_ENV

      - name: Clone DB (Prod -> Release)
        run: |
          # Clone standard
          pg_dump fitmycv_prod > /tmp/prod_sync.sql
          psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = 'fitmycv_release' AND pid <> pg_backend_pid();" postgres || true
          dropdb --if-exists fitmycv_release
          createdb fitmycv_release
          psql fitmycv_release < /tmp/prod_sync.sql
          
          # Nettoyage des clients de prod (impÃ©ratif)
          psql fitmycv_release -c "UPDATE \"User\" SET \"stripeCustomerId\" = NULL;"

      - name: Deploy via Docker Compose (Staging)
        run: |
          cd /home/erickdesmet/STAGING_SAAS/FitMyCV/app
          docker compose -f docker-compose.staging.yml down || true
          docker rm -f fitmycv-preview || true
          docker compose -f docker-compose.staging.yml up -d --force-recreate
          
          # On attend que le container soit bien "Up"
          sleep 15

      - name: Auto-Sync Stripe Products (Inside Docker)
        run: |
          # On exÃ©cute le script DIRECTEMENT dans le container qui vient de dÃ©marrer
          # car lui possÃ¨de tous les node_modules 
          docker exec fitmycv-preview node scripts/sync-staging-stripe.js

      - name: Docker Build
        run: |
          # On injecte les variables publiques pour que Next.js les "cuise" dans le JS
          docker build \
            --build-arg NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ env.RECAPTCHA_KEY }}" \
            --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ env.STRIPE_PK }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ env.APP_URL }}" \
            --build-arg NEXT_PUBLIC_APP_URL="${{ env.APP_URL }}" \
            -t fitmycv:preview .

      - name: Deploy via Docker Compose (Staging)
        run: |
          cd /home/erickdesmet/STAGING_SAAS/FitMyCV/app
          
          # 1. On tente un arrÃªt propre
          docker compose -f docker-compose.staging.yml down || true
          
          # 2. SOLUTION AU BUG : On force la suppression du container par son nom.
          # Cela dÃ©bloque l'Ã©tat "removal in progress" si Docker est perdu.
          docker rm -f fitmycv-preview || true
          
          # 3. On relance avec la nouvelle image buildÃ©e.
          # --force-recreate garantit qu'on ne rÃ©utilise pas un vieux container.
          docker compose -f docker-compose.staging.yml up -d --force-recreate
          
          # 4. On attend que l'app soit prÃªte pour les migrations
          sleep 10

      - name: Post-deploy (Migrations)
        run: |
          docker exec fitmycv-preview npm run db:migrate-deploy
          docker exec fitmycv-preview npm run db:migrate-data
