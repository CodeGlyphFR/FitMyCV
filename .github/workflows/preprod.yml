name: ðŸ§ª Pre-prod (PR Lifecycle)

on:
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened, closed]

jobs:
  deploy-preview:
    if: github.event.action != 'closed'
    runs-on: self-hosted
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Extract Public Config from local .env
        id: vars
        run: |
          # On extrait les 3 clÃ©s critiques pour le build frontend
          RECAPTCHA=$(grep '^NEXT_PUBLIC_RECAPTCHA_SITE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          STRIPE_PK=$(grep '^NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=' /home/erickdesmet/STAGING_SAAS/FitMyCV/app/.env | cut -d '=' -f2-)
          
          # On force l'URL de staging pour que Stripe et l'Auth ne pointent pas vers la prod
          echo "RECAPTCHA_KEY=$RECAPTCHA" >> $GITHUB_ENV
          echo "STRIPE_PK=$STRIPE_PK" >> $GITHUB_ENV
          echo "APP_URL=https://dev.fitmycv.io" >> $GITHUB_ENV

      - name: Clone DB (Prod -> Release)
        run: |
          # Clone standard
          pg_dump fitmycv_prod > /tmp/prod_sync.sql
          psql -c "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = 'fitmycv_release' AND pid <> pg_backend_pid();" postgres || true
          dropdb --if-exists fitmycv_release
          createdb fitmycv_release
          psql fitmycv_release < /tmp/prod_sync.sql
          
          # Nettoyage des clients de prod (impÃ©ratif)
          psql fitmycv_release -c "UPDATE \"User\" SET \"stripeCustomerId\" = NULL;"

      - name: Auto-Sync Stripe Products
        run: |
          cd $GITHUB_WORKSPACE
          
          # 1. On trouve le script (dÃ©jÃ  validÃ© par ton dernier run)
          SCRIPT_FILE=$(find . -maxdepth 3 -name "*sync*staging*stripe*.js" | head -n 1)

          # 2. CONFIGURATION DES MODULES
          # On pointe vers le dossier node_modules de ton staging pour rÃ©cupÃ©rer 'stripe' et 'pg'
          export NODE_PATH="/home/erickdesmet/STAGING_SAAS/FitMyCV/app/node_modules"

          # 3. SECRETS
          APP_PATH="/home/erickdesmet/STAGING_SAAS/FitMyCV/app"
          DB_PASS=$(grep '^DATABASE_URL=' $APP_PATH/.env | cut -d ':' -f3 | cut -d '@' -f1)
          export DATABASE_URL="postgresql://fitmycv:$DB_PASS@localhost:5432/fitmycv_release"
          export STRIPE_SECRET_KEY=$(grep '^STRIPE_SECRET_KEY=' $APP_PATH/.env | cut -d '=' -f2- | tr -d '"')

          # 4. EXÃ‰CUTION
          echo "ðŸš€ Lancement avec NODE_PATH=$NODE_PATH"
          node "$SCRIPT_FILE"

      - name: Docker Build
        run: |
          # On injecte les variables publiques pour que Next.js les "cuise" dans le JS
          docker build \
            --build-arg NEXT_PUBLIC_RECAPTCHA_SITE_KEY="${{ env.RECAPTCHA_KEY }}" \
            --build-arg NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY="${{ env.STRIPE_PK }}" \
            --build-arg NEXT_PUBLIC_SITE_URL="${{ env.APP_URL }}" \
            --build-arg NEXT_PUBLIC_APP_URL="${{ env.APP_URL }}" \
            -t fitmycv:preview .

      - name: Deploy via Docker Compose (Staging)
        run: |
          cd /home/erickdesmet/STAGING_SAAS/FitMyCV/app
          
          # 1. On tente un arrÃªt propre
          docker compose -f docker-compose.staging.yml down || true
          
          # 2. SOLUTION AU BUG : On force la suppression du container par son nom.
          # Cela dÃ©bloque l'Ã©tat "removal in progress" si Docker est perdu.
          docker rm -f fitmycv-preview || true
          
          # 3. On relance avec la nouvelle image buildÃ©e.
          # --force-recreate garantit qu'on ne rÃ©utilise pas un vieux container.
          docker compose -f docker-compose.staging.yml up -d --force-recreate
          
          # 4. On attend que l'app soit prÃªte pour les migrations
          sleep 10

      - name: Post-deploy (Migrations)
        run: |
          docker exec fitmycv-preview npm run db:migrate-deploy
          docker exec fitmycv-preview npm run db:migrate-data
